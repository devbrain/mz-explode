# Migration Strategy: Datascript-Based Executable Library

## Vision

Transform mz-explode from a specialized MZ decompression tool into a comprehensive executable analysis library capable of:
- Parsing MZ, NE, PE, PE32+ formats
- Extracting resources from executables
- Decompressing legacy compressed executables
- Providing foundation for PE Explorer and resource extraction tools

## Technology Stack

**C++ Standard**: C++20
**Build System**: Modern CMake 3.20+
**Dependencies**:
- **datascript**: Code generator for binary format parsing (via CMake FetchContent)
- **failsafe**: Header-only logging and exception handling (https://github.com/devbrain/failsafe)
- Zero runtime dependencies for parsing (datascript generates self-contained code)

**Datascript Generation Modes**:
- **Single-header mode**: Minimal, self-contained parsers for production use
- **Library mode**: Adds runtime introspection, JSON serialization, metadata access (for debugging/analysis tools)

**Key Constraint**: Datascript generates **read-only parsers**. Writing/building executables requires separate implementation.

## Phase 1: Foundation & Proof of Concept

### 1.1 Datascript Integration
- [ ] Add datascript via CMake FetchContent (requires CMake 3.20+)
- [ ] Create `formats/` directory for .ds specifications
- [ ] Set up CMake function for automatic .ds → .h code generation
- [ ] Configure generation to rebuild when .ds files change
- [ ] Document datascript build integration
- [ ] Choose generation mode: single-header for core formats, library mode for analysis tools

### 1.2 MZ Format Specification
- [ ] Create `formats/mz.ds` with MZ header structure (28-byte DOS header)
- [ ] Define relocation table structure as variable-length array
- [ ] Add validation constraints (e_magic == 0x5A4D, size calculations)
- [ ] Generate C++ parser: `ds formats/mz.ds -t cpp -o generated/`
- [ ] Verify generated API: `const uint8_t*& read()` method and parse functions
- [ ] Test with existing test data to ensure compatibility

### 1.3 Failsafe Integration
- [ ] Add failsafe library (header-only, minimal setup)
- [ ] Configure compile-time log levels for debug/release builds
- [ ] Replace manual error handling with failsafe enforcement patterns
- [ ] Use failsafe exception chaining for better error context
- [ ] Set up thread-safe logging with category-based filtering

### 1.4 Proof of Concept
- [ ] Create new `src/libexe/` directory for modern library
- [ ] Implement MZ file reader wrapper around generated datascript parser
- [ ] Use `std::span<uint8_t>` and `std::filesystem::path` for modern I/O
- [ ] Write comparison tests: old vs new MZ parsing
- [ ] Verify byte-for-byte compatibility with existing code
- [ ] Test with all embedded unittest data (pklite_*.cc, z90.cc, etc.)

**Success Criteria**: New datascript-based MZ parser passes all existing unittest test cases.

## Phase 2: Decompression Algorithms Separation

### 2.1 Architecture Redesign
Current architecture mixes parsing and decompression:
```
unpklite class:
  - Format detection ←─ move to datascript
  - Header parsing   ←─ move to datascript
  - Decompression    ←─ keep as algorithm
  - Output generation ←─ modernize
```

New architecture:
```
formats/                  → DataScript specifications (.ds files)
├── mz.ds                 → MZ/DOS executable format
├── pklite.ds            → PKLite compressed format
├── lzexe.ds             → LZEXE compressed format
├── exepack.ds           → EXEPACK compressed format
└── knowledge.ds         → Knowledge Dynamics format

generated/                → Generated parsers (auto-generated, not committed)
├── mz.h                 → MZ parser (single-header mode)
├── pklite.h             → PKLite parser
└── ...

src/libexe/
├── readers/             → Wrapper classes using generated parsers
│   ├── mz_reader.hpp   → Loads file, delegates to generated parser
│   └── ...
├── decompressors/      → Pure decompression algorithms (format-agnostic)
│   ├── pklite_decomp.hpp
│   ├── lzexe_decomp.hpp
│   └── ...
├── builders/           → EXE file writers (datascript doesn't generate these)
│   └── mz_builder.hpp  → Constructs valid MZ files
└── core/               → Common utilities (I/O, validation)
```

### 2.2 Decompressor Refactoring
Extract pure algorithms from current monolithic decoder classes:

**Current**: `unpklite` class (format parsing + decompression + output)
**New**:
```cpp
// formats/pklite.ds generates structure parser
struct PKLiteHeader { ... };  // generated by datascript

// src/libexe/decompressors/pklite_decomp.hpp
namespace libexe::decompress {
  // Pure algorithm: compressed data → decompressed data
  std::vector<uint8_t> pklite_decompress(
    std::span<const uint8_t> compressed_data,
    const PKLiteHeader& header,
    failsafe::logger& log
  );
}
```

Tasks:
- [ ] Extract PKLITE decompression algorithm to standalone function
- [ ] Extract LZEXE decompression algorithm to standalone function
- [ ] Extract EXEPACK decompression algorithm to standalone function
- [ ] Extract Knowledge Dynamics decompression algorithm
- [ ] Use failsafe logging for algorithm debugging
- [ ] Add comprehensive unit tests for each algorithm (no I/O dependencies)

### 2.3 Format Definitions in DataScript
- [ ] Define PKLITE header structures in `formats/pklite.ds`
  - Header fields, version info, compression flags
  - Validation: check magic signature, version compatibility
- [ ] Define LZEXE header structures in `formats/lzexe.ds`
  - Decompressor header, relocation table offset
- [ ] Define EXEPACK header structures in `formats/exepack.ds`
  - RB signature validation, unpacker metadata
- [ ] Define Knowledge Dynamics header structures in `formats/knowledge.ds`
- [ ] Use datascript constraints for format detection (e.g., `magic == 0x4B50`)
- [ ] Generate parsers for all formats

**Success Criteria**:
1. Decompression algorithms are pure functions, testable in isolation from file I/O
2. Format detection uses generated parsers with automatic validation
3. All parsers handle truncated/invalid input gracefully (datascript's UnexpectedEOF exceptions)

## Phase 3: PE/NE Format Support

### 3.1 PE Format Implementation
- [ ] Port PE format from exe_format_complete.ds to `formats/pe.ds`
- [ ] Implement PE32/PE32+ discriminated union
- [ ] Parse COFF header, Optional Header, Section Headers
- [ ] Parse Data Directories (exports, imports, resources, etc.)
- [ ] Create PE file reader class using generated parser

### 3.2 NE Format Implementation
- [ ] Port NE format from exe_format_complete.ds to `formats/ne.ds`
- [ ] Implement NE segment table parsing
- [ ] Implement NE resource table parsing
- [ ] Implement NE entry table parsing
- [ ] Create NE file reader class using generated parser

### 3.3 Format Detection
- [ ] Implement unified format detector (MZ/NE/PE)
- [ ] Handle DOS stub + extended header navigation (e_lfanew)
- [ ] Create factory pattern for format-specific readers
- [ ] Add format identification utility

**Success Criteria**: Library can parse PE and NE files, extract basic metadata and section information.

## Phase 4: Resource Extraction

### 4.1 PE Resources
- [ ] Implement resource directory tree traversal
- [ ] Extract icons (RT_ICON, RT_GROUP_ICON)
- [ ] Extract bitmaps (RT_BITMAP)
- [ ] Extract strings (RT_STRING)
- [ ] Extract dialogs (RT_DIALOG)
- [ ] Extract version info (RT_VERSION)
- [ ] Extract menus (RT_MENU)
- [ ] Extract accelerators (RT_ACCELERATOR)
- [ ] Support custom resource types

### 4.2 NE Resources
- [ ] Implement NE resource enumeration
- [ ] Map NE resource types to PE equivalents
- [ ] Extract common resource types
- [ ] Handle NE-specific resource formats

### 4.3 Resource API
- [ ] Design unified resource enumeration API
- [ ] Implement resource export functionality
- [ ] Support resource metadata queries
- [ ] Add resource modification capability (future)

**Success Criteria**: Can extract all common resource types from PE/NE files.

## Phase 5: Modern C++ Library Design

### 5.1 API Modernization
Replace legacy patterns with modern C++20:
- `FILE*` → `std::filesystem::path`, `std::span<uint8_t>`
- Raw pointers → `std::unique_ptr`, `std::shared_ptr`
- Manual loops → STL algorithms, ranges (C++20)
- `memcpy`/`memset` → `std::copy`, `std::fill`
- C-style casts → `static_cast`, explicit constructors
- Error codes → failsafe exceptions (structured error handling)
- Manual union type-punning → `std::bit_cast` (C++20)
- `memset` for initialization → designated initializers, default member initializers

### 5.2 Library Interface
```cpp
namespace libexe {
  // Core executable file abstraction
  class ExecutableFile {
  public:
    virtual ~ExecutableFile() = default;
    virtual std::string_view format_name() const = 0;
    virtual std::span<const uint8_t> code_section() const = 0;
    virtual std::span<const Section> sections() const = 0;
    // Uses datascript-generated parsers internally
  };

  // Format-specific implementations
  class MZFile : public ExecutableFile {
    // Wraps generated MZ parser
    // Provides high-level API over raw parsed structures
  };

  class NEFile : public ExecutableFile;
  class PEFile : public ExecutableFile;

  // Resource extraction (uses library-mode datascript for introspection)
  class ResourceDirectory;
  class Resource {
    std::string type;
    std::string name;
    std::span<const uint8_t> data;
  };

  // Section analysis
  struct Section {
    std::string name;
    uint64_t virtual_address;
    std::span<const uint8_t> data;
    SectionCharacteristics characteristics;
  };

  // Import/Export tables
  class ImportTable;
  class ExportTable;
}
```

### 5.3 Testing Strategy
- [ ] Use doctest (datascript's testing framework) for consistency
- [ ] Migrate existing unittest embedded data to test fixtures
- [ ] Create test fixtures for each format type
- [ ] Test decompression algorithms with known input/output pairs
- [ ] Test parser robustness: truncated files, invalid headers, corrupted data
- [ ] Leverage datascript's automatic validation for format correctness
- [ ] Add property-based tests for decompression roundtrips (compress + decompress = identity)
- [ ] Consider fuzzing for parser robustness (datascript parsers should handle malformed input)

**Success Criteria**: Modern, idiomatic C++20 API with comprehensive test coverage.

## Phase 6: Tool Migration

### 6.1 Command-Line Tools
- [ ] Rewrite `mzexplode` using new library
- [ ] Rewrite `mzdump` using new library
- [ ] Add `peinfo` tool for PE analysis
- [ ] Add `resextract` tool for resource extraction
- [ ] Ensure backward compatibility with existing tool interfaces

### 6.2 Documentation
- [ ] API documentation (Doxygen)
- [ ] Format specification references
- [ ] Usage examples and tutorials
- [ ] Migration guide for existing users

**Success Criteria**: All existing tools work with new library, pass regression tests.

## Phase 7: Advanced Features

### 7.1 PE Explorer Functionality
- [ ] Section disassembly integration points
- [ ] Relocation processing
- [ ] Import/Export analysis
- [ ] Digital signature verification
- [ ] Debug info (PDB) parsing hooks
- [ ] ASLR/DEP/CFG flag detection

### 7.2 Analysis Capabilities
- [ ] Entropy analysis for packing detection
- [ ] Overlay detection and extraction
- [ ] Authenticode signature validation
- [ ] Rich header parsing
- [ ] TLS callback enumeration

**Success Criteria**: Library provides all primitives needed for PE analysis tools.

## Migration Phases Timeline

**Phase 1-2**: Core foundation (datascript integration + decompressor separation)
**Phase 3**: PE/NE parsing capability
**Phase 4**: Resource extraction
**Phase 5**: API modernization
**Phase 6**: Tool migration
**Phase 7**: Advanced features

## Backward Compatibility Strategy

During migration, maintain parallel implementations:
- Keep `src/explode/` as-is (legacy)
- Build new library in `src/libexe/` (modern)
- Tools initially link against both
- Gradually switch components to new library
- Remove legacy code when all tests pass

## Success Metrics

1. **Correctness**: All existing test cases pass
2. **Performance**: New library matches or exceeds old performance
3. **Extensibility**: Adding new format takes < 100 lines of datascript
4. **Maintainability**: Code complexity reduced by >50%
5. **Capability**: Supports MZ/NE/PE/PE32+ parsing and resource extraction

## Technical Decisions (Resolved)

1. **C++ Standard**: C++20 (enables ranges, concepts, `std::span`, `std::bit_cast`)
2. **Datascript Integration**: CMake FetchContent (automatic, version-controlled)
3. **Build System**: Modern CMake 3.20+ (align with datascript requirements)
4. **Dependencies**: Minimal
   - datascript (build-time only, generates zero-dependency code)
   - failsafe (header-only, zero runtime dependencies)
   - doctest (testing only)
5. **Logging**: failsafe with compile-time level filtering (zero overhead in release builds)
6. **Exception Handling**: failsafe structured exceptions with automatic source location tracking

## Implementation Notes

### Datascript Generation Strategy
- **Single-header mode** for core format parsers (mz.ds, pklite.ds, etc.)
  - Minimal binary size
  - Fast compilation
  - No runtime introspection needed for parsing
- **Library mode** for analysis tools (PE resource inspector, metadata viewer)
  - Runtime introspection via `StructView<T>`
  - Automatic JSON serialization for debugging
  - Field-level metadata access

### CMake Integration Pattern
```cmake
include(FetchContent)

FetchContent_Declare(datascript
  GIT_REPOSITORY https://github.com/devbrain/datascript
  GIT_TAG main
)
FetchContent_MakeAvailable(datascript)

function(add_datascript_parser TARGET_NAME SCHEMA_FILE)
  set(GENERATED_HEADER "${CMAKE_BINARY_DIR}/generated/${TARGET_NAME}.h")
  add_custom_command(
    OUTPUT ${GENERATED_HEADER}
    COMMAND ds ${SCHEMA_FILE} -t cpp -o ${CMAKE_BINARY_DIR}/generated/
    DEPENDS ${SCHEMA_FILE}
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
  )
  add_library(${TARGET_NAME} INTERFACE)
  target_sources(${TARGET_NAME} INTERFACE ${GENERATED_HEADER})
  target_include_directories(${TARGET_NAME} INTERFACE ${CMAKE_BINARY_DIR}/generated)
endfunction()
```

### Error Handling Pattern
```cpp
// Use failsafe for structured error handling
try {
  auto exe = libexe::MZFile::from_file(path);  // Uses datascript parser
  // ...
} catch (const failsafe::io_error& e) {
  log.error() << "Failed to read file: " << e.what();
} catch (const UnexpectedEOF& e) {  // From datascript parser
  log.error() << "Truncated file at offset: " << e.offset();
}
```

## Next Steps

1. ✅ Review and refine strategy based on datascript/failsafe documentation
2. Set up branch with basic CMake FetchContent for datascript
3. Create `formats/mz.ds` minimal specification
4. Generate first parser and verify output structure
5. Write proof-of-concept MZ reader using generated parser
6. Compare performance and correctness against existing code
