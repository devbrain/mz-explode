# Migration Strategy: Datascript-Based Executable Library

## Vision

Transform mz-explode from a specialized MZ decompression tool into a comprehensive executable analysis library capable of:
- Parsing MZ, NE, PE, PE32+ formats
- Extracting resources from executables
- Decompressing legacy compressed executables
- Providing foundation for PE Explorer and resource extraction tools

## Technology Stack

**C++ Standard**: C++20
**Build System**: Modern CMake 3.20+ with `GenerateExportHeader`
**Dependencies**:
- **datascript**: Code generator for binary format parsing (via CMake FetchContent)
- **failsafe**: Header-only logging and exception handling (https://github.com/devbrain/failsafe)
- **doctest**: Testing framework (via CMake FetchContent, same as datascript uses)
- Zero runtime dependencies for parsing (datascript generates self-contained code)

**Datascript Generation Modes**:
- **Single-header mode**: Minimal, self-contained parsers for production use
- **Library mode**: Adds runtime introspection, JSON serialization, metadata access (for debugging/analysis tools)

**Key Constraint**: Datascript generates **read-only parsers**. Writing/building executables requires separate implementation.

## Coding Standards

**Naming Convention**: `snake_case` everywhere except:
- **Macros**: `UPPER_SNAKE_CASE` (e.g., `LIBEXE_VERSION_MAJOR`)
- **Enum values**: `UPPER_SNAKE_CASE` (e.g., `MZ_DOS`, `PKLITE_STANDARD`)

**Examples**:
```cpp
// Classes, functions, variables: snake_case
class mz_file;
void decompress_pklite();
int header_size;
std::vector<uint8_t> raw_data_;  // trailing underscore for private members

// Macros: UPPER_SNAKE_CASE
#define LIBEXE_VERSION_MAJOR 2
#define LIBEXE_EXPORT  // Generated by CMake

// Enums: UPPER_SNAKE_CASE values
enum class compression_type {
    NONE,
    PKLITE_STANDARD,
    PKLITE_EXTRA,
    LZEXE_091
};
```

**Directory Structure**:
```
mz-explode/
â”œâ”€â”€ include/libexe/           # Public API headers
â”œâ”€â”€ src/libexe/               # Implementation files
â”œâ”€â”€ unittests/                # Test suite (doctest)
â”œâ”€â”€ tools/                    # Command-line utilities
â”œâ”€â”€ formats/                  # DataScript specifications
â”œâ”€â”€ generated/                # Auto-generated parsers (not committed)
â””â”€â”€ docs/                     # Official specifications
```

**Symbol Visibility**: CMake's `generate_export_header` creates portable `LIBEXE_EXPORT` macro. All symbols hidden by default (`CMAKE_CXX_VISIBILITY_PRESET hidden`), explicit exports only.

## Phase 1: Foundation & Proof of Concept âœ… COMPLETED

### 1.1 Datascript Integration âœ…
- [x] Added datascript via CMake FetchContent (CMake 3.20+)
- [x] Created `formats/` directory for .ds specifications
- [x] Set up CMake function `add_datascript_parser()` for automatic .ds â†’ .h code generation
- [x] Configured generation to rebuild when .ds files change
- [x] Documented datascript build integration in CMakeLists.txt
- [x] Chose single-header mode for core formats (minimal runtime overhead)

**Fixed Issues**:
- DataScript uses `master` branch, not `main` (updated GIT_TAG)
- Changed package from `com.example.exe_parser` to `libexe.format` (C++-idiomatic namespace)

### 1.2 Executable Format Specifications âœ…
- [x] `formats/exe_format_complete.ds` (1336 lines) contains comprehensive format definitions:
  - **MZ format**: DOS header with validation, relocation tables
  - **NE format**: 16-bit Windows, segments, resources, entry tables
  - **PE/PE32+ format**: COFF headers, sections, data directories, resources
  - **Top-level union**: Discriminates between NE and PE using `e_lfanew`
- [x] Tested code generation: generates `ImageDosHeader.hh` (110KB C++ parser)
- [x] Verified generated API: automatic constraint validation (MZ signature check)
- [x] Generated namespace: `libexe::format` (idiomatic C++)

### 1.3 Failsafe Integration âœ…
- [x] Added failsafe library (header-only via FetchContent)
- [x] Linked to libexe target (failsafe exceptions available)
- Note: Full failsafe integration (logging, custom error handling) deferred to Phase 2

### 1.4 Directory Structure Setup âœ…
- [x] Created `include/libexe/` for public headers
- [x] Created `src/libexe/` for implementation
- [x] Created `unittests/` with doctest integration (FetchContent)
- [x] Set up CMake with `generate_export_header` for `LIBEXE_EXPORT` macro
- [x] Configured symbol visibility (`CMAKE_CXX_VISIBILITY_PRESET hidden`)
- [x] Added `BUILD_SHARED_LIBS` option (defaults to ON)

### 1.5 Proof of Concept âœ…
- [x] Created `include/libexe/mz_file.hpp` with complete snake_case API
- [x] Implemented `src/libexe/mz_file.cpp` wrapping DataScript-generated parser
- [x] Used C++20 features: `std::span<uint8_t>`, `std::filesystem::path`, `std::string_view`
- [x] Wrote `unittests/test_mz_parser.cpp` with 4 test cases, 21 assertions (all pass)
- [x] Wrote `unittests/test_legacy_data.cpp` with real compressed executables
- [x] Created `unittests/legacy_data_wrapper.cpp` to include legacy test data
- [x] **Tested with real legacy data**: PKLITE 1.12, PKLITE Extra 1.15, LZEXE 0.90/0.91, Knowledge Dynamics DOT
- [x] **All 8 test cases pass with 39 assertions**

**Test Results**:
```
Test executables processed successfully:
- PKLITE 1.12:        74,538 bytes, 8-paragraph header (128 bytes), 74,410 byte code section
- PKLITE Extra 1.15:  Parses correctly
- LZEXE 0.90:         Parses correctly
- LZEXE 0.91:         Parses correctly
- Knowledge Dynamics: 138,711 bytes, parses correctly

Header extraction verified:
- Relocation count: 1
- Min memory: 9,680 paragraphs
- Max memory: 65,535 paragraphs
- Initial registers: CS=0, IP=0, SS=4660, SP=256

Error handling verified:
- Rejects files < 28 bytes
- Rejects invalid MZ signature (DataScript constraint validation)
```

**Success Criteria**: âœ… New datascript-based MZ parser passes all existing test cases with snake_case API and handles real legacy compressed executables.

## Phase 2: Decompression Algorithms Separation âœ… COMPLETED

### 2.1 Compression Detection & API Design âœ… COMPLETED
- [x] Created `include/libexe/decompressor.hpp` with modern decompressor API
- [x] Moved `compression_type` enum to decompressor.hpp (logical location)
- [x] Designed `decompression_result` struct (code, metadata, relocations)
- [x] Designed factory function: `create_decompressor(compression_type)`
- [x] Implemented `detect_compression()` in mz_file
- [x] Signature-based detection for PKLITE (standard vs extra)
- [x] Signature-based detection for LZEXE (0.90 vs 0.91)
- [x] Framework for EXEPACK and Knowledge Dynamics detection

**Detection Results** (all 8 tests pass, 47 assertions):
- âœ… PKLITE 1.12 â†’ `PKLITE_STANDARD` (h_pklite_info = 0x210C)
- âœ… PKLITE Extra 1.15 â†’ `PKLITE_EXTRA` (h_pklite_info = 0x310F)
- âœ… LZEXE 0.90 â†’ `LZEXE_090`
- âœ… LZEXE 0.91 â†’ `LZEXE_091`

### 2.2 PKLITE Decompressor Extraction âœ… COMPLETED
- [x] Created `src/libexe/bit_reader.hpp` - Modern bit-level reader utility
- [x] Created `include/libexe/pklite_decompressor.hpp` - PKLITE decompressor interface
- [x] Created `src/libexe/pklite_decompressor.cpp` - Algorithm implementation
- [x] Extracted `adjust_length_code_standard()` from legacy code
- [x] Extracted `adjust_length_code_large()` from legacy code
- [x] Extracted `get_base_offset()` - LZ77 back-reference decoding
- [x] Extracted main decompression loop (literals + back-references)
- [x] Builds successfully, no regressions in existing tests

**Algorithm Extracted**:
- Pure algorithm - no file I/O coupling
- Modern C++20 with std::span, std::vector, RAII
- Implements decompressor interface
- Reusable bit_reader for all bit-based compression
- Supports standard and large compression models
- Handles XOR encryption variants

### 2.3 PKLITE Parameter Extraction & Testing âœ… COMPLETED (100% LEGACY COMPATIBLE)
- [x] Complete parameter extraction for all 12+ PKLITE versions
- [x] Relocation table parsing (standard and large executable formats)
- [x] Metadata extraction (SS, SP, CS, IP, checksum, min_extra_paragraphs)
- [x] Fixed bit_reader: 16-bit word buffering with eager refill (matches legacy exactly)
- [x] Fixed back-reference calculation: relative to output buffer only (not stub)
- [x] Added bounds checking for corrupted data handling
- [x] Created comprehensive test suite (test_pklite_decompress.cpp)
- [x] Created MD5 verification test (test_pklite_vs_legacy.cpp)
- [x] Created comprehensive bit_reader tests (test_bit_reader.cpp)

**Test Results** (22 test cases, 143 assertions):
- âœ… 22 test cases PASS (100%)
- âœ… 143 assertions PASS (100%)
- âœ… **MD5 Verification: ALL 5 PKLITE variants produce byte-identical output to legacy**
  - PKLITE 1.12: `e1f98f301ef8bb8710ae14469bcb2cd0` âœ…
  - PKLITE 1.15: `13482d37794b1106a85712b5e7a1227a` âœ…
  - PKLITE Extra 1.12: `8a4b841106bae1f32c7ca45e9d41c016` âœ…
  - PKLITE Extra 1.15: `56dccb4b55bdd7c57f09dbb584050a51` âœ…
  - PKLITE 1.50: `36ce063f2a979acc3ba887f4f3b9f735` âœ…

**Achievements**:
- âœ… **100% legacy compatibility verified** - PKLITE decompressor produces identical output
- âœ… Clean separation: format parsing â†’ detection â†’ decompression
- âœ… Reusable bit_reader utility for all bit-based compression algorithms
- âœ… Modern C++20 implementation with std::span, RAII, no legacy coupling
- âœ… Comprehensive test coverage with MD5 verification

**Status**: Phase 2.3 complete with **production-quality PKLITE decompressor achieving 100% legacy compatibility**.

### 2.4 LZEXE Decompressor Extraction âœ… COMPLETED
- [x] Created `include/libexe/lzexe_decompressor.hpp` - LZEXE decompressor interface
- [x] Created `src/libexe/lzexe_decompressor.cpp` - Algorithm implementation
- [x] Implemented LZEXE 0.90 decompression algorithm
- [x] Implemented LZEXE 0.91 decompression algorithm
- [x] Implemented relocation parsing for both versions
- [x] Reused bit_reader infrastructure from PKLITE
- [x] Created comprehensive test suite (test_lzexe_decompress.cpp)
- [x] All tests pass successfully

**Algorithm Features**:
- Pure algorithm - no file I/O coupling
- Modern C++20 with std::span, std::vector, RAII
- Implements decompressor interface
- Handles both LZEXE 0.90 and 0.91 formats
- Different relocation parsing strategies per version
- Simpler LZ77 encoding than PKLITE

**Test Results** (4 test cases, 27 assertions):
- âœ… 4 test cases PASS (100%)
- âœ… 27 assertions PASS (100%)
- âœ… Parameter extraction: ALL PASS
- âœ… Error handling: ALL PASS
- âœ… Full decompression LZEXE 0.90: PASS
- âœ… Full decompression LZEXE 0.91: PASS

**Overall Test Status** (18 test cases, 112 assertions):
- âœ… 17 test cases PASS (94.4%)
- âœ… 111 assertions PASS (99.1%)
- â³ 1 PKLITE decompression test (infrastructure validated, algorithm refinement deferred)

**Achievements**:
- Second decompressor successfully extracted and validated
- Confirms architecture pattern works across different compression algorithms
- bit_reader utility proves its value for reuse
- Test coverage continues to grow (27 new assertions, all pass)

### 2.5 Knowledge Dynamics Decompressor Extraction âœ… COMPLETED
- [x] Created `include/libexe/knowledge_dynamics_decompressor.hpp` - interface
- [x] Created `src/libexe/knowledge_dynamics_decompressor.cpp` - LZW implementation
- [x] Implemented LZW (Lempel-Ziv-Welch) dictionary-based decompression
- [x] Variable bit-width code reading (9-12 bits)
- [x] Dynamic dictionary with automatic expansion
- [x] Added compression detection (signature 0xE9 0x99 0x00 at offset 0x200)
- [x] Created comprehensive test suite (test_knowledge_dynamics_decompress.cpp)
- [x] All tests pass successfully

**Algorithm Features**:
- LZW compression (different from LZ77 used by PKLITE/LZEXE)
- Variable bit-width codes (9, 10, 11, 12 bits)
- Dynamic dictionary building and expansion
- Special codes: 0x0100 (reset dictionary), 0x0101 (EOF)
- Modern C++20 with std::span, std::array, RAII
- Embedded MZ header at end of file for metadata

**Test Results** (4 test cases, 12 assertions):
- âœ… 4 test cases PASS (100%)
- âœ… 12 assertions PASS (100%)
- âœ… Parameter extraction: ALL PASS
- âœ… Error handling: ALL PASS
- âœ… Full decompression: PASS

**Overall Test Status** (22 test cases, 143 assertions):
- âœ… 22 test cases PASS (100%) ðŸŽ‰
- âœ… 143 assertions PASS (100%) ðŸŽ‰

**Achievements**:
- Third decompressor successfully extracted and validated
- First LZW implementation (vs LZ77 for PKLITE/LZEXE)
- Demonstrates architecture flexibility across compression algorithms
- **100% test success rate - production quality**

### 2.6 EXEPACK Decompressor âœ… COMPLETED
- [x] Created `include/libexe/exepack_decompressor.hpp` - EXEPACK decompressor interface
- [x] Created `src/libexe/decompressors/exepack_decompressor.cpp` - Algorithm implementation
- [x] Implemented backward decompression with FILL and COPY commands
- [x] Based on exepack-1.4.0 by David Fifield (Rust reference implementation)
- [x] Implemented stub pattern matching for relocation table extraction
- [x] Implemented packed relocation table parser (16 segments format)
- [x] Added skip_len and dest_len parameter handling
- [x] Created equivalence test suite (test_exepack_vs_legacy.cpp)
- [x] Achieved 100% compatibility with exepack-1.4.0 reference

**Algorithm Features**:
- Backward decompression (from end to beginning)
- Two command types: FILL (0xB0) and COPY (0xB2)
- Up to 15 bytes zero padding allowed (exepack-1.4.0 behavior)
- Packed relocation format with 16 segments (0x0000, 0x1000, ..., 0xF000)
- Handles both 16-byte and 18-byte EXEPACK header variants
- Automatic stub end detection via byte signature pattern

**Test Results** (3 EXEPACK variants tested):
- âœ… EXEPACK MASM 4.00: PASS (relocations=2)
- âœ… EXEPACK MASM 5.00: PASS (relocations=2)
- âœ… EXEPACK MASM 5.10: PASS (relocations=2)
- âœ… Equivalence verified: All variants produce output within 15 bytes of reference
- âœ… 100% compatibility with exepack-1.4.0 test suite

**Status**: EXEPACK decompressor complete with 100% reference compatibility.

---

### âœ… PHASE 2 COMPLETION SUMMARY

**All major decompression algorithms successfully extracted and validated:**

| Decompressor | Status | Test Coverage | Legacy Compatibility |
|--------------|--------|---------------|---------------------|
| PKLITE | âœ… Complete | 5 variants, MD5 verified | 100% byte-identical |
| LZEXE | âœ… Complete | 0.90 & 0.91 tested | 100% verified |
| Knowledge Dynamics | âœ… Complete | LZW tested | 100% verified |
| EXEPACK | â¸ï¸ Deferred | No test data | N/A |

**Test Metrics:**
- **22 test cases**: 100% pass rate
- **143 assertions**: 100% pass rate
- **MD5 verification**: All PKLITE variants produce byte-identical output to legacy

**Technical Achievements:**
- âœ… Clean algorithm separation (no I/O coupling)
- âœ… Modern C++20 with std::span, RAII, zero legacy dependencies
- âœ… Reusable bit_reader utility
- âœ… Comprehensive error handling and bounds checking
- âœ… Production-quality code ready for integration

**Success Criteria Met**: All tested decompression algorithms work correctly with 100% legacy compatibility. Architecture proven across different compression types (LZ77, LZW).

---

### 2.7 Architecture Redesign (REFERENCE)
Current architecture mixes parsing and decompression:
```
unpklite class:
  - Format detection â†â”€ move to datascript
  - Header parsing   â†â”€ move to datascript
  - Decompression    â†â”€ keep as algorithm
  - Output generation â†â”€ modernize
```

New architecture:
```
mz-explode/
â”œâ”€â”€ include/libexe/              # Public API (snake_case naming)
â”‚   â”œâ”€â”€ export.hpp              # Generated by CMake (LIBEXE_EXPORT macro)
â”‚   â”œâ”€â”€ executable_file.hpp     # Base class
â”‚   â”œâ”€â”€ mz_file.hpp
â”‚   â”œâ”€â”€ ne_file.hpp
â”‚   â”œâ”€â”€ pe_file.hpp
â”‚   â”œâ”€â”€ resource.hpp
â”‚   â”œâ”€â”€ section.hpp
â”‚   â””â”€â”€ decompressors/          # Decompression algorithm headers
â”‚       â”œâ”€â”€ pklite_decompress.hpp
â”‚       â”œâ”€â”€ lzexe_decompress.hpp
â”‚       â”œâ”€â”€ exepack_decompress.hpp
â”‚       â””â”€â”€ knowledge_decompress.hpp
â”‚
â”œâ”€â”€ src/libexe/                  # Implementation (snake_case)
â”‚   â”œâ”€â”€ executable_file.cpp
â”‚   â”œâ”€â”€ mz_file.cpp
â”‚   â”œâ”€â”€ ne_file.cpp
â”‚   â”œâ”€â”€ pe_file.cpp
â”‚   â”œâ”€â”€ readers/                # File I/O and wrapper logic
â”‚   â”‚   â”œâ”€â”€ mz_reader.cpp
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ decompressors/          # Pure algorithm implementations
â”‚   â”‚   â”œâ”€â”€ pklite_decompress.cpp
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ builders/               # EXE file writers (not generated)
â”‚   â”‚   â””â”€â”€ mz_builder.cpp
â”‚   â””â”€â”€ core/                   # Common utilities
â”‚       â””â”€â”€ io.cpp
â”‚
â”œâ”€â”€ unittests/                   # Test suite (doctest)
â”‚   â”œâ”€â”€ CMakeLists.txt          # Doctest FetchContent integration
â”‚   â”œâ”€â”€ main.cpp                # Doctest main
â”‚   â”œâ”€â”€ test_mz_parser.cpp
â”‚   â”œâ”€â”€ test_pklite_decompress.cpp
â”‚   â””â”€â”€ fixtures/               # Test data
â”‚
â”œâ”€â”€ tools/                       # Command-line utilities
â”‚   â”œâ”€â”€ mzexplode/main.cpp
â”‚   â””â”€â”€ mzdump/main.cpp
â”‚
â”œâ”€â”€ formats/                     # DataScript specifications
â”‚   â”œâ”€â”€ exe_format_complete.ds  # MZ/NE/PE/PE32+ (DONE âœ…)
â”‚   â”œâ”€â”€ pklite.ds              # PKLite compressed (TODO)
â”‚   â”œâ”€â”€ lzexe.ds               # LZEXE compressed (TODO)
â”‚   â”œâ”€â”€ exepack.ds             # EXEPACK compressed (TODO)
â”‚   â””â”€â”€ knowledge.ds           # Knowledge Dynamics (TODO)
â”‚
â”œâ”€â”€ generated/                   # Auto-generated parsers (not committed)
â”‚   â””â”€â”€ com_example_exe_parser.h
â”‚
â””â”€â”€ docs/                        # Official specifications
    â”œâ”€â”€ pecoff.docx
    â”œâ”€â”€ ne.fmt
    â”œâ”€â”€ resfmt.txt
    â””â”€â”€ ...
```

### 2.2 Decompressor Refactoring
Extract pure algorithms from current monolithic decoder classes:

**Current**: `unpklite` class (format parsing + decompression + output)
**New** (snake_case API):
```cpp
// formats/pklite.ds generates structure parser
struct pklite_header { ... };  // generated by datascript

// include/libexe/decompressors/pklite_decompress.hpp
namespace libexe {

class LIBEXE_EXPORT pklite_decompressor {
public:
    // Pure algorithm: compressed data â†’ decompressed data
    static std::vector<uint8_t> decompress(
        std::span<const uint8_t> compressed_data,
        const pklite_header& header
    );

private:
    // Implementation details hidden
};

} // namespace libexe
```

Tasks:
- [ ] Extract PKLITE decompression algorithm to standalone function
- [ ] Extract LZEXE decompression algorithm to standalone function
- [ ] Extract EXEPACK decompression algorithm to standalone function
- [ ] Extract Knowledge Dynamics decompression algorithm
- [ ] Use failsafe logging for algorithm debugging
- [ ] Add comprehensive unit tests for each algorithm (no I/O dependencies)

### 2.3 Format Definitions in DataScript
- [ ] Define PKLITE header structures in `formats/pklite.ds`
  - Header fields, version info, compression flags
  - Validation: check magic signature, version compatibility
- [ ] Define LZEXE header structures in `formats/lzexe.ds`
  - Decompressor header, relocation table offset
- [ ] Define EXEPACK header structures in `formats/exepack.ds`
  - RB signature validation, unpacker metadata
- [ ] Define Knowledge Dynamics header structures in `formats/knowledge.ds`
- [ ] Use datascript constraints for format detection (e.g., `magic == 0x4B50`)
- [ ] Generate parsers for all formats

**Success Criteria**:
1. Decompression algorithms are pure functions, testable in isolation from file I/O
2. Format detection uses generated parsers with automatic validation
3. All parsers handle truncated/invalid input gracefully (datascript's UnexpectedEOF exceptions)

## Phase 3: PE/NE Format Support âœ… COMPLETED

### 3.1 PE Format Implementation âœ… COMPLETED
- [x] Uses PE structures from exe_format_complete.ds (already complete)
- [x] Implemented PE32/PE32+ auto-detection via optional header magic
- [x] Parsed COFF header (machine type, sections, timestamp, characteristics)
- [x] Parsed Optional Header (both 32-bit and 64-bit variants)
- [x] Parsed Section Headers with proper offset calculations
- [x] Created pe_file wrapper class with modern snake_case API
- [x] Implemented 15+ accessor methods for all PE header fields
- [x] Section access: sections(), find_section(), get_code_section()
- [x] Factory methods: from_file(), from_memory()
- [x] Comprehensive test suite (25 tests, 153 assertions)

**Files Created**:
- `include/libexe/pe_file.hpp` - Public API (102 lines)
- `src/libexe/pe_file.cpp` - Implementation (285 lines)
- `unittests/test_pe_parser.cpp` - Test suite (91 lines)

### 3.2 NE Format Implementation âœ… COMPLETED
- [x] Uses NE structures from exe_format_complete.ds (already complete)
- [x] Implemented NE segment table parsing with alignment shift handling
- [x] Extracted entry point from packed CS:IP 32-bit value
- [x] Extracted initial stack from packed SS:SP 32-bit value
- [x] Parsed segment table using ne_segtab offset
- [x] Created ne_file wrapper class with modern snake_case API
- [x] Implemented 20+ accessor methods for all NE header fields
- [x] Segment access: segments(), get_segment(), get_code_segment()
- [x] Target OS detection (OS/2, Windows 16-bit, DOS 4.x, etc.)
- [x] Factory methods: from_file(), from_memory()
- [x] Comprehensive test suite (29 tests, 163 assertions)

**Files Created**:
- `include/libexe/ne_file.hpp` - Public API (116 lines)
- `src/libexe/ne_file.cpp` - Implementation (275 lines)
- `unittests/test_ne_parser.cpp` - Test suite (102 lines)

### 3.3 Format Detection âœ… COMPLETED
- [x] Implemented unified format detector analyzing file headers
- [x] Handles DOS stub + extended header navigation via e_lfanew
- [x] Auto-detects MZ/NE/PE32/PE32+ formats
- [x] Created factory pattern with std::variant return type
- [x] Implemented executable_factory with load() and detect_format()
- [x] Format type name mapping for all supported formats
- [x] Comprehensive test suite (32 tests, 176 assertions)

**Implementation Details**:
- Reads DOS header to get e_lfanew pointer
- Checks signature at e_lfanew:
  - e_lfanew == 0 â†’ MZ_DOS (plain DOS executable)
  - Signature 'NE' (0x4E45) â†’ NE_WIN16
  - Signature 'PE' (0x4550) â†’ Read optional header magic:
    - 0x10B â†’ PE_WIN32 (PE32)
    - 0x20B â†’ PE_PLUS_WIN64 (PE32+)
- Returns std::variant<mz_file, ne_file, pe_file>

**Files Created**:
- `include/libexe/executable_factory.hpp` - Public API (48 lines)
- `src/libexe/executable_factory.cpp` - Implementation (138 lines)
- `unittests/test_executable_factory.cpp` - Test suite (133 lines)

**Test Results**: âœ… All 32 tests pass, 176 assertions, 100% success rate

**Success Criteria**: âœ… Library can parse PE and NE files, extract basic metadata and section information. Unified factory auto-detects all formats.

## Phase 4: Resource Extraction

### 4.1 PE Resources
- [ ] Implement resource directory tree traversal
- [ ] Extract icons (RT_ICON, RT_GROUP_ICON)
- [ ] Extract bitmaps (RT_BITMAP)
- [ ] Extract strings (RT_STRING)
- [ ] Extract dialogs (RT_DIALOG)
- [ ] Extract version info (RT_VERSION)
- [ ] Extract menus (RT_MENU)
- [ ] Extract accelerators (RT_ACCELERATOR)
- [ ] Support custom resource types

### 4.2 NE Resources
- [ ] Implement NE resource enumeration
- [ ] Map NE resource types to PE equivalents
- [ ] Extract common resource types
- [ ] Handle NE-specific resource formats

### 4.3 Resource API
- [ ] Design unified resource enumeration API
- [ ] Implement resource export functionality
- [ ] Support resource metadata queries
- [ ] Add resource modification capability (future)

**Success Criteria**: Can extract all common resource types from PE/NE files.

## Phase 5: Modern C++ Library Design

### 5.1 API Modernization
Replace legacy patterns with modern C++20:
- `FILE*` â†’ `std::filesystem::path`, `std::span<uint8_t>`
- Raw pointers â†’ `std::unique_ptr`, `std::shared_ptr`
- Manual loops â†’ STL algorithms, ranges (C++20)
- `memcpy`/`memset` â†’ `std::copy`, `std::fill`
- C-style casts â†’ `static_cast`, explicit constructors
- Error codes â†’ failsafe exceptions (structured error handling)
- Manual union type-punning â†’ `std::bit_cast` (C++20)
- `memset` for initialization â†’ designated initializers, default member initializers

### 5.2 Library Interface (snake_case API)
```cpp
// include/libexe/executable_file.hpp
namespace libexe {

enum class format_type {
    MZ_DOS,
    NE_WIN16,
    PE_WIN32,
    PE_PLUS_WIN64
};

enum class compression_type {
    NONE,
    PKLITE_STANDARD,
    PKLITE_EXTRA,
    LZEXE_090,
    LZEXE_091,
    EXEPACK,
    KNOWLEDGE_DYNAMICS
};

// Base class for all executable formats
class LIBEXE_EXPORT executable_file {
public:
    virtual ~executable_file() = default;

    virtual format_type get_format() const = 0;
    virtual std::string_view format_name() const = 0;
    virtual std::span<const uint8_t> code_section() const = 0;

    // Uses datascript-generated parsers internally
};

// MZ format
class LIBEXE_EXPORT mz_file : public executable_file {
public:
    static mz_file from_file(const std::filesystem::path& path);
    static mz_file from_memory(std::span<const uint8_t> data);

    format_type get_format() const override;
    compression_type get_compression() const;

    uint16_t initial_cs() const;
    uint16_t initial_ip() const;
    uint16_t initial_ss() const;
    uint16_t initial_sp() const;

    std::span<const uint8_t> code_section() const override;

private:
    std::vector<uint8_t> data_;
    compression_type compression_;
};

// NE format
class LIBEXE_EXPORT ne_file : public executable_file;

// PE format
class LIBEXE_EXPORT pe_file : public executable_file;

// Resource extraction
struct LIBEXE_EXPORT resource {
    std::string type;
    std::string name;
    std::span<const uint8_t> data;
};

// Section analysis
struct LIBEXE_EXPORT section {
    std::string name;
    uint64_t virtual_address;
    std::span<const uint8_t> data;
    uint32_t characteristics;
};

} // namespace libexe
```

### 5.3 Testing Strategy
- [ ] Integrate doctest via CMake FetchContent (same as datascript)
- [ ] Create `unittests/CMakeLists.txt` with doctest setup
- [ ] Migrate existing embedded test data from `src/unittest/*.cc` to `unittests/fixtures/`
- [ ] Write test files with snake_case naming: `test_mz_parser.cpp`, `test_pklite_decompress.cpp`
- [ ] Test decompression algorithms with known input/output pairs
- [ ] Test parser robustness: truncated files, invalid headers, corrupted data
- [ ] Leverage datascript's automatic validation for format correctness
- [ ] Add property-based tests for decompression roundtrips
- [ ] Consider fuzzing for parser robustness

**Doctest Integration Example**:
```cmake
# unittests/CMakeLists.txt
find_package(doctest QUIET)
if(NOT doctest_FOUND)
    FetchContent_Declare(doctest
        GIT_REPOSITORY https://github.com/doctest/doctest.git
        GIT_TAG v2.4.12
    )
    FetchContent_MakeAvailable(doctest)
endif()

add_executable(libexe_unittest
    main.cpp
    test_mz_parser.cpp
    test_pklite_decompress.cpp
)
target_link_libraries(libexe_unittest PRIVATE libexe doctest::doctest)
```

**Success Criteria**: Modern, idiomatic C++20 API with snake_case naming and comprehensive doctest coverage.

## Phase 6: Tool Migration

### 6.1 Command-Line Tools
- [ ] Rewrite `mzexplode` using new library
- [ ] Rewrite `mzdump` using new library
- [ ] Add `peinfo` tool for PE analysis
- [ ] Add `resextract` tool for resource extraction
- [ ] Ensure backward compatibility with existing tool interfaces

### 6.2 Documentation
- [ ] API documentation (Doxygen)
- [ ] Format specification references
- [ ] Usage examples and tutorials
- [ ] Migration guide for existing users

**Success Criteria**: All existing tools work with new library, pass regression tests.

## Phase 7: Advanced Features

### 7.1 PE Explorer Functionality
- [ ] Section disassembly integration points
- [ ] Relocation processing
- [ ] Import/Export analysis
- [ ] Digital signature verification
- [ ] Debug info (PDB) parsing hooks
- [ ] ASLR/DEP/CFG flag detection

### 7.2 Analysis Capabilities
- [ ] Entropy analysis for packing detection
- [ ] Overlay detection and extraction
- [ ] Authenticode signature validation
- [ ] Rich header parsing
- [ ] TLS callback enumeration

**Success Criteria**: Library provides all primitives needed for PE analysis tools.

## Migration Phases Timeline

**Phase 1-2**: Core foundation (datascript integration + decompressor separation)
**Phase 3**: PE/NE parsing capability
**Phase 4**: Resource extraction
**Phase 5**: API modernization
**Phase 6**: Tool migration
**Phase 7**: Advanced features

## Backward Compatibility Strategy

During migration, maintain parallel implementations:
- Keep `src/explode/` as-is (legacy)
- Build new library in `src/libexe/` (modern)
- Tools initially link against both
- Gradually switch components to new library
- Remove legacy code when all tests pass

## Success Metrics

1. **Correctness**: All existing test cases pass
2. **Performance**: New library matches or exceeds old performance
3. **Extensibility**: Adding new format takes < 100 lines of datascript
4. **Maintainability**: Code complexity reduced by >50%
5. **Capability**: Supports MZ/NE/PE/PE32+ parsing and resource extraction

## Technical Decisions (Resolved)

1. **C++ Standard**: C++20 (enables ranges, concepts, `std::span`, `std::bit_cast`)
2. **Naming Convention**: `snake_case` everywhere except macros (`UPPER_SNAKE_CASE`) and enum values (`UPPER_SNAKE_CASE`)
3. **Directory Structure**: `include/` + `src/` + `unittests/` (standard library layout)
4. **Symbol Visibility**: CMake's `generate_export_header` for portable `LIBEXE_EXPORT` macro
5. **Build System**: Modern CMake 3.20+ with `BUILD_SHARED_LIBS` option (shared/static library)
6. **Datascript Integration**: CMake FetchContent (automatic, version-controlled)
7. **Testing Framework**: doctest (via FetchContent, same as datascript uses)
8. **Dependencies**: Minimal
   - datascript (build-time only, generates zero-dependency code)
   - failsafe (header-only, zero runtime dependencies)
   - doctest (testing only)
9. **Logging**: failsafe with compile-time level filtering (zero overhead in release builds)
10. **Exception Handling**: failsafe structured exceptions with automatic source location tracking

## Implementation Notes

### Datascript Generation Strategy
- **Single-header mode** for core format parsers (mz.ds, pklite.ds, etc.)
  - Minimal binary size
  - Fast compilation
  - No runtime introspection needed for parsing
- **Library mode** for analysis tools (PE resource inspector, metadata viewer)
  - Runtime introspection via `StructView<T>`
  - Automatic JSON serialization for debugging
  - Field-level metadata access

### CMake Integration Pattern

```cmake
cmake_minimum_required(VERSION 3.20)
project(mz_explode VERSION 2.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(GenerateExportHeader)
include(FetchContent)

# Build options
option(BUILD_SHARED_LIBS "Build shared library" ON)
option(BUILD_TESTING "Build unit tests" ON)

# Symbol visibility (hide all by default)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN YES)

# Fetch dependencies
FetchContent_Declare(datascript
        GIT_REPOSITORY https://github.com/devbrain/datascript
        GIT_TAG main
)
FetchContent_MakeAvailable(datascript)

# Main library
add_library(libexe
        src/libexe/mz_file.cpp
        src/libexe/executable_file.cpp
        # ... more sources
)

# Generate portable export header
generate_export_header(libexe
        BASE_NAME libexe
        EXPORT_FILE_NAME ${CMAKE_CURRENT_BINARY_DIR}/include/libexe/export.hpp
)

target_include_directories(libexe
        PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>
        $<INSTALL_INTERFACE:include>
        PRIVATE
        ${CMAKE_CURRENT_BINARY_DIR}/generated
)

set_target_properties(libexe PROPERTIES
        OUTPUT_NAME exe
        VERSION ${PROJECT_VERSION}
        SOVERSION ${PROJECT_VERSION_MAJOR}
)

# DataScript code generation function
function(add_datascript_parser SCHEMA_FILE)
    get_filename_component(SCHEMA_NAME ${SCHEMA_FILE} NAME_WE)
    set(GENERATED_HEADER "${CMAKE_BINARY_DIR}/generated/${SCHEMA_NAME}.h")

    add_custom_command(
            OUTPUT ${GENERATED_HEADER}
            COMMAND ds ${SCHEMA_FILE} -t cpp -o ${CMAKE_BINARY_DIR}/generated/
            DEPENDS ${SCHEMA_FILE}
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )

    target_sources(libexe PRIVATE ${GENERATED_HEADER})
endfunction()

# Generate parsers from DataScript specs
add_datascript_parser(src/libexe/formats/exe_format_complete.ds)
```

### Error Handling Pattern (snake_case API)
```cpp
// Use failsafe for structured error handling
try {
    auto exe = libexe::mz_file::from_file(path);  // snake_case API

    if (exe.get_compression() != libexe::compression_type::NONE) {
        // Decompress if needed
        auto decompressed = libexe::pklite_decompressor::decompress(
            exe.code_section(),
            parsed_header
        );
    }

} catch (const failsafe::io_error& e) {
    log.error() << "Failed to read file: " << e.what();
} catch (const unexpected_eof& e) {  // From datascript parser (snake_case)
    log.error() << "Truncated file at offset: " << e.offset();
}
```

## Next Steps

**âœ… COMPLETED:**
1. âœ… Review and refine strategy based on datascript/failsafe documentation
2. âœ… Establish coding standards (snake_case, directory structure, symbol visibility)
3. âœ… Obtain complete executable format specification (`exe_format_complete.ds`)
4. âœ… Set up directory structure: `include/libexe/`, `src/libexe/`, `unittests/`
5. âœ… Configure CMake with `generate_export_header` and doctest integration
6. âœ… Generate first parser from `exe_format_complete.ds` and verify output
7. âœ… Write `include/libexe/mz_file.hpp` with snake_case API
8. âœ… Implement `src/libexe/mz_file.cpp` wrapping generated parser
9. âœ… Create `unittests/test_mz_parser.cpp` with doctest
10. âœ… Verify 100% legacy compatibility (all decompressors produce byte-identical output)

**Phase 1 & 2 Complete!** All decompression algorithms extracted with 100% test success rate.

**ðŸŽ¯ RECOMMENDED NEXT PHASE (Phase 3: PE/NE Format Support):**

This is the highest-value addition that transforms mz-explode into a comprehensive executable analysis library:

1. **PE Format Implementation** (using existing `exe_format_complete.ds`)
   - Implement `include/libexe/pe_file.hpp` with snake_case API
   - Wrap DataScript-generated PE parser
   - Parse COFF header, Optional Header, Section Headers
   - Parse Data Directories (exports, imports, resources)
   - Create comprehensive test suite

2. **NE Format Implementation** (using existing `exe_format_complete.ds`)
   - Implement `include/libexe/ne_file.hpp` with snake_case API
   - Wrap DataScript-generated NE parser
   - Parse segment tables, resource tables, entry tables
   - Create comprehensive test suite

3. **Unified Format Detection**
   - Implement factory pattern: `executable_file::open(path)` auto-detects format
   - Handle DOS stub + extended header navigation (e_lfanew)
   - Support MZ/NE/PE/PE32+ discrimination

**Why Phase 3 Next?**
- All format specifications already exist in `exe_format_complete.ds` (1336 lines)
- DataScript parsers already generated and tested
- Natural progression: MZ â†’ NE â†’ PE
- Unlocks Phase 4 (resource extraction) - the main value proposition
- Provides foundation for modern PE analysis tools
