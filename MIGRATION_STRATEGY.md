# Migration Strategy: Datascript-Based Executable Library

## Vision

Transform mz-explode from a specialized MZ decompression tool into a comprehensive executable analysis library capable of:
- Parsing MZ, NE, PE, PE32+ formats
- Extracting resources from executables
- Decompressing legacy compressed executables
- Providing foundation for PE Explorer and resource extraction tools

## Technology Stack

**C++ Standard**: C++20
**Build System**: Modern CMake 3.20+ with `GenerateExportHeader`
**Dependencies**:
- **datascript**: Code generator for binary format parsing (via CMake FetchContent)
- **failsafe**: Header-only logging and exception handling (https://github.com/devbrain/failsafe)
- **doctest**: Testing framework (via CMake FetchContent, same as datascript uses)
- Zero runtime dependencies for parsing (datascript generates self-contained code)

**Datascript Generation Modes**:
- **Single-header mode**: Minimal, self-contained parsers for production use
- **Library mode**: Adds runtime introspection, JSON serialization, metadata access (for debugging/analysis tools)

**Key Constraint**: Datascript generates **read-only parsers**. Writing/building executables requires separate implementation.

## Coding Standards

**Naming Convention**: `snake_case` everywhere except:
- **Macros**: `UPPER_SNAKE_CASE` (e.g., `LIBEXE_VERSION_MAJOR`)
- **Enum values**: `UPPER_SNAKE_CASE` (e.g., `MZ_DOS`, `PKLITE_STANDARD`)

**Examples**:
```cpp
// Classes, functions, variables: snake_case
class mz_file;
void decompress_pklite();
int header_size;
std::vector<uint8_t> raw_data_;  // trailing underscore for private members

// Macros: UPPER_SNAKE_CASE
#define LIBEXE_VERSION_MAJOR 2
#define LIBEXE_EXPORT  // Generated by CMake

// Enums: UPPER_SNAKE_CASE values
enum class compression_type {
    NONE,
    PKLITE_STANDARD,
    PKLITE_EXTRA,
    LZEXE_091
};
```

**Directory Structure**:
```
mz-explode/
├── include/libexe/           # Public API headers
├── src/libexe/               # Implementation files
├── unittests/                # Test suite (doctest)
├── tools/                    # Command-line utilities
├── formats/                  # DataScript specifications
├── generated/                # Auto-generated parsers (not committed)
└── docs/                     # Official specifications
```

**Symbol Visibility**: CMake's `generate_export_header` creates portable `LIBEXE_EXPORT` macro. All symbols hidden by default (`CMAKE_CXX_VISIBILITY_PRESET hidden`), explicit exports only.

## Phase 1: Foundation & Proof of Concept ✅ COMPLETED

### 1.1 Datascript Integration ✅
- [x] Added datascript via CMake FetchContent (CMake 3.20+)
- [x] Created `formats/` directory for .ds specifications
- [x] Set up CMake function `add_datascript_parser()` for automatic .ds → .h code generation
- [x] Configured generation to rebuild when .ds files change
- [x] Documented datascript build integration in CMakeLists.txt
- [x] Chose single-header mode for core formats (minimal runtime overhead)

**Fixed Issues**:
- DataScript uses `master` branch, not `main` (updated GIT_TAG)
- Changed package from `com.example.exe_parser` to `libexe.format` (C++-idiomatic namespace)

### 1.2 Executable Format Specifications ✅
- [x] `formats/exe_format_complete.ds` (1336 lines) contains comprehensive format definitions:
  - **MZ format**: DOS header with validation, relocation tables
  - **NE format**: 16-bit Windows, segments, resources, entry tables
  - **PE/PE32+ format**: COFF headers, sections, data directories, resources
  - **Top-level union**: Discriminates between NE and PE using `e_lfanew`
- [x] Tested code generation: generates `ImageDosHeader.hh` (110KB C++ parser)
- [x] Verified generated API: automatic constraint validation (MZ signature check)
- [x] Generated namespace: `libexe::format` (idiomatic C++)

### 1.3 Failsafe Integration ✅
- [x] Added failsafe library (header-only via FetchContent)
- [x] Linked to libexe target (failsafe exceptions available)
- Note: Full failsafe integration (logging, custom error handling) deferred to Phase 2

### 1.4 Directory Structure Setup ✅
- [x] Created `include/libexe/` for public headers
- [x] Created `src/libexe/` for implementation
- [x] Created `unittests/` with doctest integration (FetchContent)
- [x] Set up CMake with `generate_export_header` for `LIBEXE_EXPORT` macro
- [x] Configured symbol visibility (`CMAKE_CXX_VISIBILITY_PRESET hidden`)
- [x] Added `BUILD_SHARED_LIBS` option (defaults to ON)

### 1.5 Proof of Concept ✅
- [x] Created `include/libexe/mz_file.hpp` with complete snake_case API
- [x] Implemented `src/libexe/mz_file.cpp` wrapping DataScript-generated parser
- [x] Used C++20 features: `std::span<uint8_t>`, `std::filesystem::path`, `std::string_view`
- [x] Wrote `unittests/test_mz_parser.cpp` with 4 test cases, 21 assertions (all pass)
- [x] Wrote `unittests/test_legacy_data.cpp` with real compressed executables
- [x] Created `unittests/legacy_data_wrapper.cpp` to include legacy test data
- [x] **Tested with real legacy data**: PKLITE 1.12, PKLITE Extra 1.15, LZEXE 0.90/0.91, Knowledge Dynamics DOT
- [x] **All 8 test cases pass with 39 assertions**

**Test Results**:
```
Test executables processed successfully:
- PKLITE 1.12:        74,538 bytes, 8-paragraph header (128 bytes), 74,410 byte code section
- PKLITE Extra 1.15:  Parses correctly
- LZEXE 0.90:         Parses correctly
- LZEXE 0.91:         Parses correctly
- Knowledge Dynamics: 138,711 bytes, parses correctly

Header extraction verified:
- Relocation count: 1
- Min memory: 9,680 paragraphs
- Max memory: 65,535 paragraphs
- Initial registers: CS=0, IP=0, SS=4660, SP=256

Error handling verified:
- Rejects files < 28 bytes
- Rejects invalid MZ signature (DataScript constraint validation)
```

**Success Criteria**: ✅ New datascript-based MZ parser passes all existing test cases with snake_case API and handles real legacy compressed executables.

## Phase 2: Decompression Algorithms Separation

### 2.1 Architecture Redesign
Current architecture mixes parsing and decompression:
```
unpklite class:
  - Format detection ←─ move to datascript
  - Header parsing   ←─ move to datascript
  - Decompression    ←─ keep as algorithm
  - Output generation ←─ modernize
```

New architecture:
```
mz-explode/
├── include/libexe/              # Public API (snake_case naming)
│   ├── export.hpp              # Generated by CMake (LIBEXE_EXPORT macro)
│   ├── executable_file.hpp     # Base class
│   ├── mz_file.hpp
│   ├── ne_file.hpp
│   ├── pe_file.hpp
│   ├── resource.hpp
│   ├── section.hpp
│   └── decompressors/          # Decompression algorithm headers
│       ├── pklite_decompress.hpp
│       ├── lzexe_decompress.hpp
│       ├── exepack_decompress.hpp
│       └── knowledge_decompress.hpp
│
├── src/libexe/                  # Implementation (snake_case)
│   ├── executable_file.cpp
│   ├── mz_file.cpp
│   ├── ne_file.cpp
│   ├── pe_file.cpp
│   ├── readers/                # File I/O and wrapper logic
│   │   ├── mz_reader.cpp
│   │   └── ...
│   ├── decompressors/          # Pure algorithm implementations
│   │   ├── pklite_decompress.cpp
│   │   └── ...
│   ├── builders/               # EXE file writers (not generated)
│   │   └── mz_builder.cpp
│   └── core/                   # Common utilities
│       └── io.cpp
│
├── unittests/                   # Test suite (doctest)
│   ├── CMakeLists.txt          # Doctest FetchContent integration
│   ├── main.cpp                # Doctest main
│   ├── test_mz_parser.cpp
│   ├── test_pklite_decompress.cpp
│   └── fixtures/               # Test data
│
├── tools/                       # Command-line utilities
│   ├── mzexplode/main.cpp
│   └── mzdump/main.cpp
│
├── formats/                     # DataScript specifications
│   ├── exe_format_complete.ds  # MZ/NE/PE/PE32+ (DONE ✅)
│   ├── pklite.ds              # PKLite compressed (TODO)
│   ├── lzexe.ds               # LZEXE compressed (TODO)
│   ├── exepack.ds             # EXEPACK compressed (TODO)
│   └── knowledge.ds           # Knowledge Dynamics (TODO)
│
├── generated/                   # Auto-generated parsers (not committed)
│   └── com_example_exe_parser.h
│
└── docs/                        # Official specifications
    ├── pecoff.docx
    ├── ne.fmt
    ├── resfmt.txt
    └── ...
```

### 2.2 Decompressor Refactoring
Extract pure algorithms from current monolithic decoder classes:

**Current**: `unpklite` class (format parsing + decompression + output)
**New** (snake_case API):
```cpp
// formats/pklite.ds generates structure parser
struct pklite_header { ... };  // generated by datascript

// include/libexe/decompressors/pklite_decompress.hpp
namespace libexe {

class LIBEXE_EXPORT pklite_decompressor {
public:
    // Pure algorithm: compressed data → decompressed data
    static std::vector<uint8_t> decompress(
        std::span<const uint8_t> compressed_data,
        const pklite_header& header
    );

private:
    // Implementation details hidden
};

} // namespace libexe
```

Tasks:
- [ ] Extract PKLITE decompression algorithm to standalone function
- [ ] Extract LZEXE decompression algorithm to standalone function
- [ ] Extract EXEPACK decompression algorithm to standalone function
- [ ] Extract Knowledge Dynamics decompression algorithm
- [ ] Use failsafe logging for algorithm debugging
- [ ] Add comprehensive unit tests for each algorithm (no I/O dependencies)

### 2.3 Format Definitions in DataScript
- [ ] Define PKLITE header structures in `formats/pklite.ds`
  - Header fields, version info, compression flags
  - Validation: check magic signature, version compatibility
- [ ] Define LZEXE header structures in `formats/lzexe.ds`
  - Decompressor header, relocation table offset
- [ ] Define EXEPACK header structures in `formats/exepack.ds`
  - RB signature validation, unpacker metadata
- [ ] Define Knowledge Dynamics header structures in `formats/knowledge.ds`
- [ ] Use datascript constraints for format detection (e.g., `magic == 0x4B50`)
- [ ] Generate parsers for all formats

**Success Criteria**:
1. Decompression algorithms are pure functions, testable in isolation from file I/O
2. Format detection uses generated parsers with automatic validation
3. All parsers handle truncated/invalid input gracefully (datascript's UnexpectedEOF exceptions)

## Phase 3: PE/NE Format Support

### 3.1 PE Format Implementation
- [ ] Port PE format from exe_format_complete.ds to `formats/pe.ds`
- [ ] Implement PE32/PE32+ discriminated union
- [ ] Parse COFF header, Optional Header, Section Headers
- [ ] Parse Data Directories (exports, imports, resources, etc.)
- [ ] Create PE file reader class using generated parser

### 3.2 NE Format Implementation
- [ ] Port NE format from exe_format_complete.ds to `formats/ne.ds`
- [ ] Implement NE segment table parsing
- [ ] Implement NE resource table parsing
- [ ] Implement NE entry table parsing
- [ ] Create NE file reader class using generated parser

### 3.3 Format Detection
- [ ] Implement unified format detector (MZ/NE/PE)
- [ ] Handle DOS stub + extended header navigation (e_lfanew)
- [ ] Create factory pattern for format-specific readers
- [ ] Add format identification utility

**Success Criteria**: Library can parse PE and NE files, extract basic metadata and section information.

## Phase 4: Resource Extraction

### 4.1 PE Resources
- [ ] Implement resource directory tree traversal
- [ ] Extract icons (RT_ICON, RT_GROUP_ICON)
- [ ] Extract bitmaps (RT_BITMAP)
- [ ] Extract strings (RT_STRING)
- [ ] Extract dialogs (RT_DIALOG)
- [ ] Extract version info (RT_VERSION)
- [ ] Extract menus (RT_MENU)
- [ ] Extract accelerators (RT_ACCELERATOR)
- [ ] Support custom resource types

### 4.2 NE Resources
- [ ] Implement NE resource enumeration
- [ ] Map NE resource types to PE equivalents
- [ ] Extract common resource types
- [ ] Handle NE-specific resource formats

### 4.3 Resource API
- [ ] Design unified resource enumeration API
- [ ] Implement resource export functionality
- [ ] Support resource metadata queries
- [ ] Add resource modification capability (future)

**Success Criteria**: Can extract all common resource types from PE/NE files.

## Phase 5: Modern C++ Library Design

### 5.1 API Modernization
Replace legacy patterns with modern C++20:
- `FILE*` → `std::filesystem::path`, `std::span<uint8_t>`
- Raw pointers → `std::unique_ptr`, `std::shared_ptr`
- Manual loops → STL algorithms, ranges (C++20)
- `memcpy`/`memset` → `std::copy`, `std::fill`
- C-style casts → `static_cast`, explicit constructors
- Error codes → failsafe exceptions (structured error handling)
- Manual union type-punning → `std::bit_cast` (C++20)
- `memset` for initialization → designated initializers, default member initializers

### 5.2 Library Interface (snake_case API)
```cpp
// include/libexe/executable_file.hpp
namespace libexe {

enum class format_type {
    MZ_DOS,
    NE_WIN16,
    PE_WIN32,
    PE_PLUS_WIN64
};

enum class compression_type {
    NONE,
    PKLITE_STANDARD,
    PKLITE_EXTRA,
    LZEXE_090,
    LZEXE_091,
    EXEPACK,
    KNOWLEDGE_DYNAMICS
};

// Base class for all executable formats
class LIBEXE_EXPORT executable_file {
public:
    virtual ~executable_file() = default;

    virtual format_type get_format() const = 0;
    virtual std::string_view format_name() const = 0;
    virtual std::span<const uint8_t> code_section() const = 0;

    // Uses datascript-generated parsers internally
};

// MZ format
class LIBEXE_EXPORT mz_file : public executable_file {
public:
    static mz_file from_file(const std::filesystem::path& path);
    static mz_file from_memory(std::span<const uint8_t> data);

    format_type get_format() const override;
    compression_type get_compression() const;

    uint16_t initial_cs() const;
    uint16_t initial_ip() const;
    uint16_t initial_ss() const;
    uint16_t initial_sp() const;

    std::span<const uint8_t> code_section() const override;

private:
    std::vector<uint8_t> data_;
    compression_type compression_;
};

// NE format
class LIBEXE_EXPORT ne_file : public executable_file;

// PE format
class LIBEXE_EXPORT pe_file : public executable_file;

// Resource extraction
struct LIBEXE_EXPORT resource {
    std::string type;
    std::string name;
    std::span<const uint8_t> data;
};

// Section analysis
struct LIBEXE_EXPORT section {
    std::string name;
    uint64_t virtual_address;
    std::span<const uint8_t> data;
    uint32_t characteristics;
};

} // namespace libexe
```

### 5.3 Testing Strategy
- [ ] Integrate doctest via CMake FetchContent (same as datascript)
- [ ] Create `unittests/CMakeLists.txt` with doctest setup
- [ ] Migrate existing embedded test data from `src/unittest/*.cc` to `unittests/fixtures/`
- [ ] Write test files with snake_case naming: `test_mz_parser.cpp`, `test_pklite_decompress.cpp`
- [ ] Test decompression algorithms with known input/output pairs
- [ ] Test parser robustness: truncated files, invalid headers, corrupted data
- [ ] Leverage datascript's automatic validation for format correctness
- [ ] Add property-based tests for decompression roundtrips
- [ ] Consider fuzzing for parser robustness

**Doctest Integration Example**:
```cmake
# unittests/CMakeLists.txt
find_package(doctest QUIET)
if(NOT doctest_FOUND)
    FetchContent_Declare(doctest
        GIT_REPOSITORY https://github.com/doctest/doctest.git
        GIT_TAG v2.4.12
    )
    FetchContent_MakeAvailable(doctest)
endif()

add_executable(libexe_unittest
    main.cpp
    test_mz_parser.cpp
    test_pklite_decompress.cpp
)
target_link_libraries(libexe_unittest PRIVATE libexe doctest::doctest)
```

**Success Criteria**: Modern, idiomatic C++20 API with snake_case naming and comprehensive doctest coverage.

## Phase 6: Tool Migration

### 6.1 Command-Line Tools
- [ ] Rewrite `mzexplode` using new library
- [ ] Rewrite `mzdump` using new library
- [ ] Add `peinfo` tool for PE analysis
- [ ] Add `resextract` tool for resource extraction
- [ ] Ensure backward compatibility with existing tool interfaces

### 6.2 Documentation
- [ ] API documentation (Doxygen)
- [ ] Format specification references
- [ ] Usage examples and tutorials
- [ ] Migration guide for existing users

**Success Criteria**: All existing tools work with new library, pass regression tests.

## Phase 7: Advanced Features

### 7.1 PE Explorer Functionality
- [ ] Section disassembly integration points
- [ ] Relocation processing
- [ ] Import/Export analysis
- [ ] Digital signature verification
- [ ] Debug info (PDB) parsing hooks
- [ ] ASLR/DEP/CFG flag detection

### 7.2 Analysis Capabilities
- [ ] Entropy analysis for packing detection
- [ ] Overlay detection and extraction
- [ ] Authenticode signature validation
- [ ] Rich header parsing
- [ ] TLS callback enumeration

**Success Criteria**: Library provides all primitives needed for PE analysis tools.

## Migration Phases Timeline

**Phase 1-2**: Core foundation (datascript integration + decompressor separation)
**Phase 3**: PE/NE parsing capability
**Phase 4**: Resource extraction
**Phase 5**: API modernization
**Phase 6**: Tool migration
**Phase 7**: Advanced features

## Backward Compatibility Strategy

During migration, maintain parallel implementations:
- Keep `src/explode/` as-is (legacy)
- Build new library in `src/libexe/` (modern)
- Tools initially link against both
- Gradually switch components to new library
- Remove legacy code when all tests pass

## Success Metrics

1. **Correctness**: All existing test cases pass
2. **Performance**: New library matches or exceeds old performance
3. **Extensibility**: Adding new format takes < 100 lines of datascript
4. **Maintainability**: Code complexity reduced by >50%
5. **Capability**: Supports MZ/NE/PE/PE32+ parsing and resource extraction

## Technical Decisions (Resolved)

1. **C++ Standard**: C++20 (enables ranges, concepts, `std::span`, `std::bit_cast`)
2. **Naming Convention**: `snake_case` everywhere except macros (`UPPER_SNAKE_CASE`) and enum values (`UPPER_SNAKE_CASE`)
3. **Directory Structure**: `include/` + `src/` + `unittests/` (standard library layout)
4. **Symbol Visibility**: CMake's `generate_export_header` for portable `LIBEXE_EXPORT` macro
5. **Build System**: Modern CMake 3.20+ with `BUILD_SHARED_LIBS` option (shared/static library)
6. **Datascript Integration**: CMake FetchContent (automatic, version-controlled)
7. **Testing Framework**: doctest (via FetchContent, same as datascript uses)
8. **Dependencies**: Minimal
   - datascript (build-time only, generates zero-dependency code)
   - failsafe (header-only, zero runtime dependencies)
   - doctest (testing only)
9. **Logging**: failsafe with compile-time level filtering (zero overhead in release builds)
10. **Exception Handling**: failsafe structured exceptions with automatic source location tracking

## Implementation Notes

### Datascript Generation Strategy
- **Single-header mode** for core format parsers (mz.ds, pklite.ds, etc.)
  - Minimal binary size
  - Fast compilation
  - No runtime introspection needed for parsing
- **Library mode** for analysis tools (PE resource inspector, metadata viewer)
  - Runtime introspection via `StructView<T>`
  - Automatic JSON serialization for debugging
  - Field-level metadata access

### CMake Integration Pattern
```cmake
cmake_minimum_required(VERSION 3.20)
project(mz_explode VERSION 2.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(GenerateExportHeader)
include(FetchContent)

# Build options
option(BUILD_SHARED_LIBS "Build shared library" ON)
option(BUILD_TESTING "Build unit tests" ON)

# Symbol visibility (hide all by default)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN YES)

# Fetch dependencies
FetchContent_Declare(datascript
    GIT_REPOSITORY https://github.com/devbrain/datascript
    GIT_TAG main
)
FetchContent_MakeAvailable(datascript)

# Main library
add_library(libexe
    src/libexe/mz_file.cpp
    src/libexe/executable_file.cpp
    # ... more sources
)

# Generate portable export header
generate_export_header(libexe
    BASE_NAME libexe
    EXPORT_FILE_NAME ${CMAKE_CURRENT_BINARY_DIR}/include/libexe/export.hpp
)

target_include_directories(libexe
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_BINARY_DIR}/generated
)

set_target_properties(libexe PROPERTIES
    OUTPUT_NAME exe
    VERSION ${PROJECT_VERSION}
    SOVERSION ${PROJECT_VERSION_MAJOR}
)

# DataScript code generation function
function(add_datascript_parser SCHEMA_FILE)
    get_filename_component(SCHEMA_NAME ${SCHEMA_FILE} NAME_WE)
    set(GENERATED_HEADER "${CMAKE_BINARY_DIR}/generated/${SCHEMA_NAME}.h")

    add_custom_command(
        OUTPUT ${GENERATED_HEADER}
        COMMAND ds ${SCHEMA_FILE} -t cpp -o ${CMAKE_BINARY_DIR}/generated/
        DEPENDS ${SCHEMA_FILE}
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )

    target_sources(libexe PRIVATE ${GENERATED_HEADER})
endfunction()

# Generate parsers from DataScript specs
add_datascript_parser(formats/exe_format_complete.ds)
```

### Error Handling Pattern (snake_case API)
```cpp
// Use failsafe for structured error handling
try {
    auto exe = libexe::mz_file::from_file(path);  // snake_case API

    if (exe.get_compression() != libexe::compression_type::NONE) {
        // Decompress if needed
        auto decompressed = libexe::pklite_decompressor::decompress(
            exe.code_section(),
            parsed_header
        );
    }

} catch (const failsafe::io_error& e) {
    log.error() << "Failed to read file: " << e.what();
} catch (const unexpected_eof& e) {  // From datascript parser (snake_case)
    log.error() << "Truncated file at offset: " << e.offset();
}
```

## Next Steps

1. ✅ Review and refine strategy based on datascript/failsafe documentation
2. ✅ Establish coding standards (snake_case, directory structure, symbol visibility)
3. ✅ Obtain complete executable format specification (`exe_format_complete.ds`)
4. Set up directory structure: `include/libexe/`, `src/libexe/`, `unittests/`
5. Configure CMake with `generate_export_header` and doctest integration
6. Generate first parser from `exe_format_complete.ds` and verify output
7. Write `include/libexe/mz_file.hpp` with snake_case API
8. Implement `src/libexe/mz_file.cpp` wrapping generated parser
9. Create `unittests/test_mz_parser.cpp` with doctest
10. Compare performance and correctness against legacy implementation
