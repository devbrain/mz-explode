// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/pe_file.hpp>
#include <libexe/pe/section_parser.hpp>
#include <libexe/resources/pe_resource_directory.hpp>
#include <libexe/pe/directories/import.hpp>
#include <libexe/pe/directories/export.hpp>
#include <libexe/pe/directories/relocation.hpp>
#include <libexe/pe/directories/tls.hpp>
#include <libexe/pe/directories/debug.hpp>
#include <libexe/pe/directories/load_config.hpp>
#include <libexe/pe/directories/exception.hpp>
#include <libexe/pe/directories/delay_import.hpp>
#include <libexe/pe/directories/bound_import.hpp>
#include <libexe/pe/directories/security.hpp>
#include <libexe/pe/directories/com_descriptor.hpp>
#include <libexe/pe/directories/iat.hpp>
#include <libexe/pe/directories/global_ptr.hpp>
#include <libexe/pe/directories/architecture.hpp>
#include <libexe/pe/directories/reserved.hpp>
#include <libexe/core/entropy.hpp>
#include <libexe/pe/overlay.hpp>
#include "core/file_utils.hpp"
#include <formats/mz/mz.hh>  // Generated by DataScript (modular)
#include <formats/pe/pe_header/pe_header.hh>  // Generated by DataScript (modular)
#include <stdexcept>
#include <cstring>
#include <algorithm>
#include <set>

namespace libexe {

// Factory methods
pe_file pe_file::from_file(const std::filesystem::path& path) {
    auto data = internal::read_file_to_memory(path);
    return from_memory(data);
}

pe_file pe_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS stub + PE header pointer
        throw std::runtime_error("File too small to be a valid PE executable");
    }

    pe_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_pe_headers();
        file.parse_sections();
    } catch (const formats::pe::pe_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid PE file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing PE file: ") + e.what());
    }

    return file;
}

void pe_file::parse_pe_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Parse DOS header to get e_lfanew (offset to PE header)
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);

    if (dos_header.e_magic != 0x5A4D) {
        throw std::runtime_error("Not a valid DOS/PE file (invalid MZ signature)");
    }

    // Get offset to PE header
    pe_offset_ = dos_header.e_lfanew;
    if (pe_offset_ == 0 || pe_offset_ >= data_.size() - 4) {
        throw std::runtime_error("Not a PE file (e_lfanew invalid)");
    }

    // Verify PE signature "PE\0\0"
    ptr = data_.data() + pe_offset_;
    uint32_t pe_sig = formats::pe::pe_header::read_uint32_le(ptr, end);
    if (pe_sig != 0x00004550) {
        throw std::runtime_error("Not a PE file (invalid PE signature)");
    }

    // Parse COFF File Header
    auto coff_header = formats::pe::pe_header::image_file_header::read(ptr, end);
    machine_type_ = static_cast<uint16_t>(coff_header.Machine);
    section_count_ = coff_header.NumberOfSections;
    timestamp_ = coff_header.TimeDateStamp;
    characteristics_ = static_cast<uint16_t>(coff_header.Characteristics);

    // Parse Optional Header
    optional_header_offset_ = static_cast<uint32_t>(ptr - data_.data());

    // Read magic to determine PE32 vs PE32+
    if (ptr + 2 > end) {
        throw std::runtime_error("PE file truncated (no optional header magic)");
    }

    uint16_t magic = formats::pe::pe_header::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind for full header parse

    // Get optional header size from COFF header (we need this for edge cases and overlay detection)
    // Rewind to read COFF header
    const uint8_t* coff_ptr = data_.data() + pe_offset_ + 4;  // Skip PE signature
    auto coff_hdr = formats::pe::pe_header::image_file_header::read(coff_ptr, end);
    uint16_t opt_hdr_size = coff_hdr.SizeOfOptionalHeader;
    optional_header_size_ = opt_hdr_size;

    if (magic == 0x010B) {
        // PE32 (32-bit)
        is_64bit_ = false;
        auto opt_header = formats::pe::pe_header::image_optional_header32::read(ptr, end);

        image_base_ = opt_header.ImageBase;
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

        // Extract data directories from DataScript-parsed array
        for (size_t i = 0; i < opt_header.DataDirectory.size() && i < 16; i++) {
            data_directories_[i].rva = opt_header.DataDirectory[i].VirtualAddress;
            data_directories_[i].size = opt_header.DataDirectory[i].Size;
        }

        // Handle edge case: NumberOfRvaAndSizes < 16 but optional header size allows more
        // Windows loaders typically ignore NumberOfRvaAndSizes and use all available data dirs
        // PE32 base size (without data dirs) is 96 bytes
        const size_t pe32_base_size = 96;
        size_t parsed_count = opt_header.DataDirectory.size();
        if (parsed_count < 16 && opt_hdr_size > pe32_base_size) {
            size_t available_dir_bytes = opt_hdr_size - pe32_base_size;
            size_t max_dirs = available_dir_bytes / 8;  // Each data dir is 8 bytes
            if (max_dirs > 16) max_dirs = 16;

            // Read additional data directories directly from file
            const uint8_t* dir_ptr = data_.data() + optional_header_offset_ + pe32_base_size + parsed_count * 8;
            for (size_t i = parsed_count; i < max_dirs && dir_ptr + 8 <= end; i++) {
                uint32_t rva = dir_ptr[0] | (dir_ptr[1] << 8) | (dir_ptr[2] << 16) | (dir_ptr[3] << 24);
                uint32_t size = dir_ptr[4] | (dir_ptr[5] << 8) | (dir_ptr[6] << 16) | (dir_ptr[7] << 24);
                data_directories_[i].rva = rva;
                data_directories_[i].size = size;
                dir_ptr += 8;
            }
        }

    } else if (magic == 0x020B) {
        // PE32+ (64-bit)
        is_64bit_ = true;
        auto opt_header = formats::pe::pe_header::image_optional_header64::read(ptr, end);

        image_base_ = opt_header.ImageBase;
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

        // Extract data directories from DataScript-parsed array
        for (size_t i = 0; i < opt_header.DataDirectory.size() && i < 16; i++) {
            data_directories_[i].rva = opt_header.DataDirectory[i].VirtualAddress;
            data_directories_[i].size = opt_header.DataDirectory[i].Size;
        }

        // Handle edge case: NumberOfRvaAndSizes < 16 but optional header size allows more
        // PE32+ base size (without data dirs) is 112 bytes
        const size_t pe64_base_size = 112;
        size_t parsed_count = opt_header.DataDirectory.size();
        if (parsed_count < 16 && opt_hdr_size > pe64_base_size) {
            size_t available_dir_bytes = opt_hdr_size - pe64_base_size;
            size_t max_dirs = available_dir_bytes / 8;
            if (max_dirs > 16) max_dirs = 16;

            // Read additional data directories directly from file
            const uint8_t* dir_ptr = data_.data() + optional_header_offset_ + pe64_base_size + parsed_count * 8;
            for (size_t i = parsed_count; i < max_dirs && dir_ptr + 8 <= end; i++) {
                uint32_t rva = dir_ptr[0] | (dir_ptr[1] << 8) | (dir_ptr[2] << 16) | (dir_ptr[3] << 24);
                uint32_t size = dir_ptr[4] | (dir_ptr[5] << 8) | (dir_ptr[6] << 16) | (dir_ptr[7] << 24);
                data_directories_[i].rva = rva;
                data_directories_[i].size = size;
                dir_ptr += 8;
            }
        }

    } else {
        throw std::runtime_error("Invalid PE optional header magic: " + std::to_string(magic));
    }

    // =========================================================================
    // Generate diagnostics for detected anomalies
    // =========================================================================

    // Check for zero sections (Vista+ allows this)
    if (section_count_ == 0) {
        diagnostics_.anomaly(diagnostic_code::COFF_ZERO_SECTIONS,
            "NumberOfSections is zero - section-less PE file",
            pe_offset_ + 6);
    }

    // Check for excessive sections (spec says 96 max, but Windows allows more)
    if (section_count_ > 96) {
        diagnostics_.warning(diagnostic_code::COFF_EXCESSIVE_SECTIONS,
            "NumberOfSections exceeds PE/COFF spec limit of 96: " + std::to_string(section_count_),
            pe_offset_ + 6);
    }

    // Check for low alignment mode (writable header)
    if (file_alignment_ == section_alignment_ && file_alignment_ <= 0x200) {
        diagnostics_.warning(diagnostic_code::OPT_LOW_ALIGNMENT,
            "Low alignment mode - FileAlignment == SectionAlignment <= 0x200 (header is writable)",
            optional_header_offset_);
    }

    // Check for non-power-of-2 alignment values
    auto is_power_of_2 = [](uint32_t n) { return n > 0 && (n & (n - 1)) == 0; };
    if (file_alignment_ != 0 && !is_power_of_2(file_alignment_)) {
        diagnostics_.warning(diagnostic_code::OPT_NON_POWER2_ALIGNMENT,
            "FileAlignment (0x" + std::to_string(file_alignment_) +
            ") is not a power of 2 - may cause loading issues",
            optional_header_offset_);
    }
    if (section_alignment_ != 0 && !is_power_of_2(section_alignment_)) {
        diagnostics_.warning(diagnostic_code::OPT_NON_POWER2_ALIGNMENT,
            "SectionAlignment (0x" + std::to_string(section_alignment_) +
            ") is not a power of 2 - may cause loading issues",
            optional_header_offset_);
    }

    // Check for zero entry point
    if (entry_point_rva_ == 0) {
        diagnostics_.info(diagnostic_code::OPT_ZERO_ENTRY_POINT,
            "AddressOfEntryPoint is zero - execution starts at DOS header (MZ signature)",
            optional_header_offset_ + (is_64bit_ ? 16 : 16));  // EP offset in opt header
    }

    // Check for entry point outside image
    if (entry_point_rva_ != 0 && entry_point_rva_ >= size_of_image_) {
        diagnostics_.anomaly(diagnostic_code::OPT_EP_OUTSIDE_IMAGE,
            "AddressOfEntryPoint (0x" + std::to_string(entry_point_rva_) +
            ") is beyond SizeOfImage (0x" + std::to_string(size_of_image_) + ")",
            optional_header_offset_ + (is_64bit_ ? 16 : 16));
    }

    // Check for entry point in header
    if (entry_point_rva_ != 0 && entry_point_rva_ < size_of_headers_) {
        diagnostics_.warning(diagnostic_code::OPT_EP_IN_HEADER,
            "AddressOfEntryPoint (0x" + std::to_string(entry_point_rva_) +
            ") is within header region (SizeOfHeaders: 0x" + std::to_string(size_of_headers_) + ")",
            optional_header_offset_ + (is_64bit_ ? 16 : 16));
    }

    // Check for invalid ImageBase (zero or kernel space)
    if (image_base_ == 0) {
        diagnostics_.warning(diagnostic_code::OPT_INVALID_IMAGEBASE,
            "ImageBase is zero - file will be relocated to 0x10000",
            optional_header_offset_ + (is_64bit_ ? 24 : 28));
    } else if (image_base_ >= 0x80000000 && !is_64bit_) {
        // For 32-bit, >= 0x80000000 is kernel space
        diagnostics_.warning(diagnostic_code::OPT_INVALID_IMAGEBASE,
            "ImageBase is in kernel space (0x" + std::to_string(image_base_) +
            ") - file will be relocated",
            optional_header_offset_ + 28);
    }

    // Check for unaligned ImageBase (must be 64KB aligned)
    if ((image_base_ % 0x10000) != 0) {
        diagnostics_.warning(diagnostic_code::OPT_UNALIGNED_IMAGEBASE,
            "ImageBase (0x" + std::to_string(image_base_) +
            ") is not 64KB aligned - file will be relocated",
            optional_header_offset_ + (is_64bit_ ? 24 : 28));
    }

    // Check if PE header is in overlay (beyond mapped region)
    if (pe_offset_ >= size_of_headers_) {
        diagnostics_.anomaly(diagnostic_code::PE_HEADER_IN_OVERLAY,
            "PE header is in overlay region (e_lfanew: 0x" + std::to_string(pe_offset_) +
            " >= SizeOfHeaders: 0x" + std::to_string(size_of_headers_) + ")",
            0x3C);  // e_lfanew offset in DOS header
    }

    // Check for writable header in low alignment mode
    if (file_alignment_ == section_alignment_ && file_alignment_ <= 0x200) {
        diagnostics_.warning(diagnostic_code::PE_WRITABLE_HEADER,
            "PE header is writable due to low alignment mode (can be modified by relocations)",
            optional_header_offset_);
    }

    // Check for dual PE header (PE header spans section boundary)
    // This happens when e_lfanew + header_size > SizeOfHeaders
    {
        // Calculate header size: PE signature (4) + COFF header (20) + optional header size
        size_t pe_header_total_size = 4 + 20 + opt_hdr_size + section_count_ * 40;
        if (pe_offset_ + pe_header_total_size > size_of_headers_) {
            diagnostics_.anomaly(diagnostic_code::PE_DUAL_HEADER,
                "PE header extends beyond SizeOfHeaders - different header on disk vs memory",
                pe_offset_);
        }
    }

    // Check for oversized optional header
    {
        size_t expected_size = is_64bit_ ? 112 : 96;  // Base size without data dirs
        expected_size += 16 * 8;  // Add 16 data directories (8 bytes each)
        if (opt_hdr_size > expected_size) {
            diagnostics_.warning(diagnostic_code::OPT_OVERSIZED_OPTIONAL_HDR,
                "SizeOfOptionalHeader (" + std::to_string(opt_hdr_size) +
                ") exceeds expected size (" + std::to_string(expected_size) +
                ") - section table at unusual location",
                pe_offset_ + 20);  // SizeOfOptionalHeader offset in COFF header
        }
    }

    // Check for RELOCS_STRIPPED contradiction (flag set but relocs present)
    {
        bool relocs_stripped = (characteristics_ & 0x0001) != 0;  // IMAGE_FILE_RELOCS_STRIPPED
        bool has_relocs = has_data_directory(directory_entry::BASERELOC) &&
                          data_directory_rva(directory_entry::BASERELOC) != 0 &&
                          data_directory_size(directory_entry::BASERELOC) != 0;
        if (relocs_stripped && has_relocs) {
            diagnostics_.warning(diagnostic_code::COFF_RELOCS_STRIPPED_IGNORED,
                "IMAGE_FILE_RELOCS_STRIPPED flag is set but relocation directory exists - flag ignored by loader",
                pe_offset_ + 22);  // Characteristics offset in COFF header
        }
    }

    // =========================================================================
    // PE/COFF Spec-based validations
    // =========================================================================

    // Check for deprecated COFF characteristics flags (per PE/COFF spec)
    // These flags should be zero in modern PE files
    {
        constexpr uint16_t IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004;   // Deprecated
        constexpr uint16_t IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008; // Deprecated
        constexpr uint16_t IMAGE_FILE_AGGRESSIVE_WS_TRIM = 0x0010;  // Obsolete, must be zero
        constexpr uint16_t IMAGE_FILE_BYTES_REVERSED_LO = 0x0080;   // Deprecated, should be zero
        constexpr uint16_t IMAGE_FILE_BYTES_REVERSED_HI = 0x8000;   // Deprecated, should be zero

        uint16_t deprecated_flags = characteristics_ &
            (IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
             IMAGE_FILE_AGGRESSIVE_WS_TRIM | IMAGE_FILE_BYTES_REVERSED_LO |
             IMAGE_FILE_BYTES_REVERSED_HI);

        if (deprecated_flags != 0) {
            std::string flag_names;
            if (deprecated_flags & IMAGE_FILE_LINE_NUMS_STRIPPED)
                flag_names += "LINE_NUMS_STRIPPED ";
            if (deprecated_flags & IMAGE_FILE_LOCAL_SYMS_STRIPPED)
                flag_names += "LOCAL_SYMS_STRIPPED ";
            if (deprecated_flags & IMAGE_FILE_AGGRESSIVE_WS_TRIM)
                flag_names += "AGGRESSIVE_WS_TRIM ";
            if (deprecated_flags & IMAGE_FILE_BYTES_REVERSED_LO)
                flag_names += "BYTES_REVERSED_LO ";
            if (deprecated_flags & IMAGE_FILE_BYTES_REVERSED_HI)
                flag_names += "BYTES_REVERSED_HI ";

            diagnostics_.info(diagnostic_code::COFF_DEPRECATED_FLAG,
                "Deprecated COFF characteristic flags set: " + flag_names,
                pe_offset_ + 22);
        }
    }

    // Check for COFF symbol table (deprecated for images, should be zero)
    {
        // Re-read COFF header to get PointerToSymbolTable and NumberOfSymbols
        const uint8_t* coff_check_ptr = data_.data() + pe_offset_ + 4;
        auto coff_check = formats::pe::pe_header::image_file_header::read(coff_check_ptr, end);

        if (coff_check.PointerToSymbolTable != 0 || coff_check.NumberOfSymbols != 0) {
            diagnostics_.info(diagnostic_code::COFF_SYMBOL_TABLE_PRESENT,
                "COFF symbol table present (deprecated for images) - "
                "PointerToSymbolTable: 0x" + std::to_string(coff_check.PointerToSymbolTable) +
                ", NumberOfSymbols: " + std::to_string(coff_check.NumberOfSymbols),
                pe_offset_ + 12);
        }
    }

    // Check FileAlignment range (per PE/COFF spec: must be 512-64K)
    if (file_alignment_ != 0 && (file_alignment_ < 512 || file_alignment_ > 65536)) {
        diagnostics_.warning(diagnostic_code::OPT_FILE_ALIGNMENT_RANGE,
            "FileAlignment (0x" + std::to_string(file_alignment_) +
            ") outside spec range 512-64K (0x200-0x10000)",
            optional_header_offset_);
    }

    // Check SectionAlignment >= FileAlignment (per PE/COFF spec)
    if (section_alignment_ != 0 && file_alignment_ != 0 &&
        section_alignment_ < file_alignment_) {
        diagnostics_.warning(diagnostic_code::OPT_SECTION_LT_FILE_ALIGN,
            "SectionAlignment (0x" + std::to_string(section_alignment_) +
            ") is less than FileAlignment (0x" + std::to_string(file_alignment_) + ")",
            optional_header_offset_);
    }

    // Check SizeOfImage is multiple of SectionAlignment (per PE/COFF spec)
    if (section_alignment_ != 0 && (size_of_image_ % section_alignment_) != 0) {
        diagnostics_.warning(diagnostic_code::OPT_SIZE_OF_IMAGE_UNALIGNED,
            "SizeOfImage (0x" + std::to_string(size_of_image_) +
            ") is not a multiple of SectionAlignment (0x" + std::to_string(section_alignment_) + ")",
            optional_header_offset_);
    }

    // Check SizeOfHeaders is multiple of FileAlignment (per PE/COFF spec)
    if (file_alignment_ != 0 && (size_of_headers_ % file_alignment_) != 0) {
        diagnostics_.warning(diagnostic_code::OPT_SIZE_OF_HEADERS_UNALIGNED,
            "SizeOfHeaders (0x" + std::to_string(size_of_headers_) +
            ") is not a multiple of FileAlignment (0x" + std::to_string(file_alignment_) + ")",
            optional_header_offset_);
    }

    // Check for reserved DllCharacteristics bits (0x0001-0x0008 must be zero)
    {
        constexpr uint16_t RESERVED_DLL_CHAR_MASK = 0x000F;  // Bits 0-3 are reserved
        uint16_t reserved_bits = dll_characteristics_ & RESERVED_DLL_CHAR_MASK;
        if (reserved_bits != 0) {
            diagnostics_.warning(diagnostic_code::OPT_RESERVED_DLL_CHAR,
                "Reserved DllCharacteristics bits set: 0x" + std::to_string(reserved_bits),
                optional_header_offset_);
        }
    }

    // Check for overlapping data directories
    detect_overlapping_directories();

    // Check for data directories in header region
    detect_directories_in_header();
}

void pe_file::parse_sections() {
    // Get optional header size from COFF header
    const uint8_t* ptr = data_.data() + pe_offset_ + 4;  // Skip PE signature
    const uint8_t* end = data_.data() + data_.size();

    auto coff_header = formats::pe::pe_header::image_file_header::read(ptr, end);
    uint16_t opt_hdr_size = coff_header.SizeOfOptionalHeader;

    // Use pe_section_parser for consistent section parsing
    // Pass file_alignment for proper offset rounding
    sections_ = pe_section_parser::parse_sections(
        data_,
        pe_offset_,
        section_count_,
        opt_hdr_size,
        file_alignment_
    );
}

void pe_file::detect_overlapping_directories() {
    // Check if any two data directories point to overlapping regions
    // This is a common obfuscation technique

    struct dir_region {
        directory_entry entry;
        uint32_t rva;
        uint32_t size;
    };

    std::vector<dir_region> regions;

    // Collect all non-empty directories
    for (int i = 0; i < 16; i++) {
        auto entry = static_cast<directory_entry>(i);
        if (has_data_directory(entry)) {
            uint32_t rva = data_directory_rva(entry);
            uint32_t size = data_directory_size(entry);
            if (rva != 0 && size != 0) {
                regions.push_back({entry, rva, size});
            }
        }
    }

    // Check for overlaps
    for (size_t i = 0; i < regions.size(); i++) {
        for (size_t j = i + 1; j < regions.size(); j++) {
            uint32_t start1 = regions[i].rva;
            uint32_t end1 = start1 + regions[i].size;
            uint32_t start2 = regions[j].rva;
            uint32_t end2 = start2 + regions[j].size;

            // Check if ranges overlap
            if (start1 < end2 && start2 < end1) {
                diagnostics_.warning(diagnostic_code::OVERLAPPING_DIRECTORIES,
                    "Data directories overlap: " +
                    std::to_string(static_cast<int>(regions[i].entry)) + " and " +
                    std::to_string(static_cast<int>(regions[j].entry)),
                    optional_header_offset_);
            }
        }
    }
}

void pe_file::detect_directories_in_header() {
    // Check if any data directory is within the header region
    // This is valid but unusual, especially for zero-section files

    for (int i = 0; i < 16; i++) {
        auto entry = static_cast<directory_entry>(i);
        if (has_data_directory(entry)) {
            uint32_t rva = data_directory_rva(entry);
            uint32_t size = data_directory_size(entry);

            // Skip security directory - its "RVA" is actually a file offset
            if (entry == directory_entry::SECURITY) {
                continue;
            }

            if (rva != 0 && size != 0 && rva < size_of_headers_) {
                diagnostics_.info(diagnostic_code::DIRECTORY_IN_HEADER,
                    "Data directory " + std::to_string(i) + " is within header region (RVA: 0x" +
                    std::to_string(rva) + ", SizeOfHeaders: 0x" + std::to_string(size_of_headers_) + ")",
                    optional_header_offset_ + (is_64bit_ ? 112 : 96) + i * 8);
            }
        }
    }
}

void pe_file::check_relocation_anomalies(const base_relocation_directory& relocs) const {
    // Check for unusual relocation types (potential obfuscation)
    // Types 1,2,4,5,9 are rare on x86/x64 and may indicate obfuscation

    bool has_unusual_types = false;
    bool has_invalid_types = false;
    bool has_header_targets = false;
    size_t header_reloc_count = 0;

    for (const auto& block : relocs.blocks) {
        for (const auto& entry : block.entries) {
            uint8_t type = static_cast<uint8_t>(entry.type);

            // Check for invalid type (8 or >10)
            if (type == 8 || type > 10) {
                has_invalid_types = true;
            }

            // Check for unusual types (1, 2, 4, 5, 9) on x86/x64
            // These are rarely used legitimately on Intel platforms
            if (type == 1 || type == 2 || type == 4 || type == 5 || type == 9) {
                // Only flag as unusual for x86/x64 machines
                if (machine_type_ == static_cast<uint16_t>(pe_machine_type::I386) ||
                    machine_type_ == static_cast<uint16_t>(pe_machine_type::AMD64)) {
                    has_unusual_types = true;
                }
            }

            // Check for relocations targeting header region
            if (entry.rva < size_of_headers_ && entry.type != relocation_type::ABSOLUTE) {
                has_header_targets = true;
                header_reloc_count++;
            }
        }
    }

    if (has_invalid_types) {
        diagnostics_.anomaly(diagnostic_code::RELOC_INVALID_TYPE,
            "Relocation directory contains invalid type (type 8 or >10)",
            data_directory_rva(directory_entry::BASERELOC));
    }

    if (has_unusual_types) {
        diagnostics_.warning(diagnostic_code::RELOC_UNUSUAL_TYPE,
            "Relocation directory contains unusual types (1, 2, 4, 5, or 9) - potential obfuscation",
            data_directory_rva(directory_entry::BASERELOC));
    }

    if (has_header_targets) {
        diagnostics_.warning(diagnostic_code::RELOC_HEADER_TARGET,
            std::to_string(header_reloc_count) + " relocation(s) target header region - may modify PE header at runtime",
            data_directory_rva(directory_entry::BASERELOC));
    }

    // Check for virtual code pattern: Invalid ImageBase + high relocation count
    // This technique uses relocations to construct code from zeroed sections
    if ((image_base_ == 0 || image_base_ >= 0x80000000) && relocs.active_relocations() > 100) {
        diagnostics_.warning(diagnostic_code::RELOC_VIRTUAL_CODE,
            "Potential virtual code technique: invalid ImageBase (0x" +
            std::to_string(image_base_) + ") with " +
            std::to_string(relocs.active_relocations()) + " active relocations",
            data_directory_rva(directory_entry::BASERELOC));
    }

    // Check for high relocation density (many relocs per section)
    // This could indicate virtual code or obfuscation
    for (const auto& section : sections_) {
        size_t section_relocs = 0;
        for (const auto& block : relocs.blocks) {
            if (block.page_rva >= section.virtual_address &&
                block.page_rva < section.virtual_address + section.virtual_size) {
                section_relocs += block.active_relocation_count();
            }
        }

        // If section has many relocations relative to its size, flag it
        // Threshold: more than 1 relocation per 4 bytes on average
        if (section.raw_data_size > 0 && section_relocs > section.raw_data_size / 4) {
            diagnostics_.info(diagnostic_code::RELOC_HIGH_DENSITY,
                "Section '" + section.name + "' has high relocation density: " +
                std::to_string(section_relocs) + " relocations in " +
                std::to_string(section.raw_data_size) + " bytes",
                section.virtual_address);
        }
    }
}

void pe_file::check_import_anomalies(const import_directory& imports, const std::string& module_name) const {
    // Check for truncated import directory
    if (imports.truncated) {
        diagnostics_.warning(diagnostic_code::IMP_TRUNCATED,
            "Import directory is truncated - missing null terminator",
            data_directory_rva(directory_entry::IMPORT));
    }

    // Helper to check if a string contains non-printable characters
    auto has_binary_chars = [](const std::string& s) {
        for (unsigned char c : s) {
            if (c < 32 || c >= 127) {
                return true;
            }
        }
        return false;
    };

    // Helper for case-insensitive comparison
    auto iequals = [](const std::string& a, const std::string& b) {
        if (a.size() != b.size()) return false;
        for (size_t i = 0; i < a.size(); ++i) {
            if (tolower(static_cast<unsigned char>(a[i])) !=
                tolower(static_cast<unsigned char>(b[i]))) {
                return false;
            }
        }
        return true;
    };

    // Normalize module name for self-import detection
    std::string normalized_module = module_name;
    // Remove .dll extension if present
    if (normalized_module.size() > 4) {
        std::string ext = normalized_module.substr(normalized_module.size() - 4);
        for (auto& c : ext) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
        if (ext == ".dll") {
            normalized_module = normalized_module.substr(0, normalized_module.size() - 4);
        }
    }

    for (const auto& dll : imports.dlls) {
        // Check for empty IAT (no functions imported from DLL)
        if (dll.functions.empty()) {
            diagnostics_.warning(diagnostic_code::IMP_EMPTY_IAT,
                "DLL '" + dll.name + "' has empty IAT - DLL will not be loaded",
                dll.iat_rva);
        }

        // Check for binary characters in DLL name
        if (has_binary_chars(dll.name)) {
            diagnostics_.warning(diagnostic_code::IMP_BINARY_NAME,
                "DLL name contains non-printable characters",
                dll.name_rva);
        }

        // Check for self-import (module imports from itself)
        if (!normalized_module.empty()) {
            std::string normalized_dll = dll.name;
            // Remove .dll extension if present
            if (normalized_dll.size() > 4) {
                std::string ext = normalized_dll.substr(normalized_dll.size() - 4);
                for (auto& c : ext) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
                if (ext == ".dll") {
                    normalized_dll = normalized_dll.substr(0, normalized_dll.size() - 4);
                }
            }
            if (iequals(normalized_module, normalized_dll)) {
                diagnostics_.warning(diagnostic_code::IMP_SELF_IMPORT,
                    "Module imports from itself: '" + dll.name + "'",
                    dll.name_rva);
            }
        }

        // Check for function names with binary characters
        for (const auto& func : dll.functions) {
            if (!func.is_ordinal && has_binary_chars(func.name)) {
                diagnostics_.warning(diagnostic_code::IMP_BINARY_NAME,
                    "Import name contains non-printable characters in DLL '" + dll.name + "'",
                    static_cast<uint32_t>(func.iat_rva));
            }
        }
    }
}

void pe_file::check_export_anomalies(const export_directory& exports) const {
    // Helper to check if a string contains non-printable characters
    auto has_binary_chars = [](const std::string& s) {
        for (unsigned char c : s) {
            if (c < 32 || c >= 127) {
                return true;
            }
        }
        return false;
    };

    // Helper for case-insensitive comparison
    auto iequals = [](const std::string& a, const std::string& b) {
        if (a.size() != b.size()) return false;
        for (size_t i = 0; i < a.size(); ++i) {
            if (tolower(static_cast<unsigned char>(a[i])) !=
                tolower(static_cast<unsigned char>(b[i]))) {
                return false;
            }
        }
        return true;
    };

    // Build set of export names for self-forwarding detection
    std::set<std::string> export_names;
    for (const auto& e : exports.exports) {
        if (e.has_name && !e.name.empty()) {
            std::string name_lower = e.name;
            for (auto& c : name_lower) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
            export_names.insert(name_lower);
        }
    }

    // Check for forwarder loops (simplified - check for self-forwarding)
    for (const auto& exp : exports.exports) {
        if (exp.is_forwarder) {
            // Check for binary characters in export name
            if (exp.has_name && has_binary_chars(exp.name)) {
                diagnostics_.warning(diagnostic_code::EXP_BINARY_NAME,
                    "Export name contains non-printable characters: ordinal " +
                    std::to_string(exp.ordinal),
                    exp.rva);
            }

            // Check if forwarder points to same module (potential loop)
            // Forwarder format is "MODULE.Function" or "MODULE.#ordinal"
            size_t dot_pos = exp.forwarder_name.find('.');
            if (dot_pos != std::string::npos) {
                std::string fwd_module = exp.forwarder_name.substr(0, dot_pos);
                std::string fwd_function = exp.forwarder_name.substr(dot_pos + 1);

                // Normalize for comparison
                std::string fwd_module_lower = fwd_module;
                for (auto& c : fwd_module_lower) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));

                std::string fwd_function_lower = fwd_function;
                for (auto& c : fwd_function_lower) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));

                bool is_self_forward = false;

                // Method 1: Compare against module name if available
                if (!exports.module_name.empty()) {
                    std::string module_lower = exports.module_name;
                    for (auto& c : module_lower) c = static_cast<char>(tolower(static_cast<unsigned char>(c)));

                    // Remove .dll extension if present
                    if (module_lower.size() > 4 &&
                        module_lower.substr(module_lower.size() - 4) == ".dll") {
                        module_lower = module_lower.substr(0, module_lower.size() - 4);
                    }

                    is_self_forward = (module_lower == fwd_module_lower);
                }

                // Method 2: If module name is empty, check if target function exists in our exports
                if (!is_self_forward && exports.module_name.empty()) {
                    // Check if the forwarder target function is one of our exports
                    is_self_forward = (export_names.count(fwd_function_lower) > 0);
                }

                if (is_self_forward) {
                    diagnostics_.warning(diagnostic_code::EXP_FORWARDER_LOOP,
                        "Export '" + exp.name + "' forwards to same module: " +
                        exp.forwarder_name + " - potential infinite loop",
                        exp.rva);
                }
            }
        } else {
            // Check for binary characters in non-forwarder export names
            if (exp.has_name && has_binary_chars(exp.name)) {
                diagnostics_.warning(diagnostic_code::EXP_BINARY_NAME,
                    "Export name contains non-printable characters: ordinal " +
                    std::to_string(exp.ordinal),
                    exp.rva);
            }
        }
    }

    // Check for large ordinal gaps
    if (exports.exports.size() >= 2) {
        uint16_t min_ordinal = 0xFFFF;
        uint16_t max_ordinal = 0;
        for (const auto& exp : exports.exports) {
            if (exp.ordinal < min_ordinal) min_ordinal = exp.ordinal;
            if (exp.ordinal > max_ordinal) max_ordinal = exp.ordinal;
        }

        uint32_t range = max_ordinal - min_ordinal + 1;
        if (range > exports.exports.size() * 2 && range > 100) {
            diagnostics_.info(diagnostic_code::EXP_ORDINAL_GAP,
                "Large gap in export ordinals: range " + std::to_string(min_ordinal) +
                "-" + std::to_string(max_ordinal) + " with only " +
                std::to_string(exports.exports.size()) + " exports",
                data_directory_rva(directory_entry::EXPORT));
        }
    }
}

// Interface implementation
format_type pe_file::get_format() const {
    return is_64bit_ ? format_type::PE_PLUS_WIN64 : format_type::PE_WIN32;
}

std::string_view pe_file::format_name() const {
    return is_64bit_ ? "PE32+ (64-bit Windows)" : "PE32 (32-bit Windows)";
}

std::span<const uint8_t> pe_file::code_section() const {
    auto code_sec = get_code_section();
    if (code_sec) {
        return code_sec->data;
    }
    return {};
}

// PE-specific accessors
bool pe_file::is_64bit() const {
    return is_64bit_;
}

pe_machine_type pe_file::machine_type() const {
    return static_cast<pe_machine_type>(machine_type_);
}

uint16_t pe_file::section_count() const {
    return section_count_;
}

uint32_t pe_file::timestamp() const {
    return timestamp_;
}

pe_file_characteristics pe_file::characteristics() const {
    return static_cast<pe_file_characteristics>(characteristics_);
}

uint64_t pe_file::image_base() const {
    return image_base_;
}

uint32_t pe_file::entry_point_rva() const {
    return entry_point_rva_;
}

uint32_t pe_file::section_alignment() const {
    return section_alignment_;
}

uint32_t pe_file::file_alignment() const {
    return file_alignment_;
}

uint32_t pe_file::size_of_image() const {
    return size_of_image_;
}

uint32_t pe_file::size_of_headers() const {
    return size_of_headers_;
}

pe_subsystem pe_file::subsystem() const {
    return static_cast<pe_subsystem>(subsystem_);
}

pe_dll_characteristics pe_file::dll_characteristics() const {
    return static_cast<pe_dll_characteristics>(dll_characteristics_);
}

// =============================================================================
// Edge Case Detection Methods
// =============================================================================

bool pe_file::is_low_alignment() const {
    // Low alignment mode: FileAlignment == SectionAlignment and both <= 0x200
    // In this mode, raw addresses equal virtual addresses and the header is writable
    return file_alignment_ == section_alignment_ && file_alignment_ <= 0x200;
}

uint64_t pe_file::effective_image_base() const {
    // If ImageBase is invalid (0 or kernel space for 32-bit), file will be relocated
    // The loader typically uses 0x10000 as the fallback base address

    if (image_base_ == 0) {
        return 0x10000;
    }

    // For 32-bit executables, kernel space (>= 0x80000000) is invalid for user mode
    if (!is_64bit_ && image_base_ >= 0x80000000) {
        return 0x10000;
    }

    // For 64-bit, high values like 0xFFFE0000 are used for "virtual code" technique
    // These also cause relocation to 0x10000
    if (is_64bit_ && image_base_ >= 0xFFFF000000000000ULL) {
        return 0x10000;
    }

    // ImageBase must be 64KB aligned; if not, relocation will occur
    if ((image_base_ % 0x10000) != 0) {
        // Loader will round down to nearest 64KB boundary or use 0x10000
        return 0x10000;
    }

    return image_base_;
}

const std::vector<pe_section>& pe_file::sections() const {
    return sections_;
}

std::optional<pe_section> pe_file::find_section(const std::string& name) const {
    for (const auto& section : sections_) {
        if (section.name == name) {
            return section;
        }
    }
    return std::nullopt;
}

std::optional<pe_section> pe_file::get_code_section() const {
    // Try common code section names
    auto text_sec = find_section(".text");
    if (text_sec) return text_sec;

    auto code_sec = find_section("CODE");
    if (code_sec) return code_sec;

    // If not found by name, return first executable section
    for (const auto& section : sections_) {
        if (section.is_executable()) {
            return section;
        }
    }

    return std::nullopt;
}

// =============================================================================
// Resource Access
// =============================================================================

bool pe_file::has_resources() const {
    // Check if .rsrc section exists
    return find_section(".rsrc").has_value();
}

std::shared_ptr<resource_directory> pe_file::resources() const {
    auto rsrc_section = find_section(".rsrc");

    if (!rsrc_section) {
        // Return empty resource directory
        return std::make_shared<pe_resource_directory>(std::span<const uint8_t>(), 0);
    }

    // Create PE resource directory from .rsrc section data
    return std::make_shared<pe_resource_directory>(
        rsrc_section->data,
        rsrc_section->virtual_address
    );
}

// =============================================================================
// Data Directory Access
// =============================================================================

uint32_t pe_file::data_directory_rva(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        throw std::out_of_range("Invalid data directory entry: " + std::to_string(index));
    }
    return data_directories_[index].rva;
}

uint32_t pe_file::data_directory_size(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        throw std::out_of_range("Invalid data directory entry: " + std::to_string(index));
    }
    return data_directories_[index].size;
}

bool pe_file::has_data_directory(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        return false;
    }

    // Most data directories only need RVA != 0 check
    // Many PE files (especially Corkami test corpus) set size = 0 for variable-length
    // structures like import/export tables that are null-terminated or block-based.
    // The parsers will validate the actual data.

    // Special cases where size MUST be checked:
    // - Security: File offset-based, size is mandatory for certificate data
    // - None currently, but keeping structure for future additions

    // For all other directories: only check RVA != 0
    return data_directories_[index].rva != 0;
}

std::shared_ptr<import_directory> pe_file::imports() const {
    // Lazy parsing: only parse imports on first access
    if (imports_) {
        return imports_;
    }

    // Check if import directory exists
    if (!has_data_directory(directory_entry::IMPORT)) {
        // Return empty import directory
        imports_ = std::make_shared<import_directory>();
        return imports_;
    }

    // Get import directory location
    uint32_t import_rva = data_directory_rva(directory_entry::IMPORT);
    uint32_t import_size = data_directory_size(directory_entry::IMPORT);

    // Parse import directory
    try {
        auto parsed = import_directory_parser::parse(
            data_,
            sections_,
            import_rva,
            import_size,
            is_64bit_
        );
        imports_ = std::make_shared<import_directory>(std::move(parsed));

        // Check for import anomalies
        // Get module name from exports if available (for self-import detection)
        std::string module_name;
        if (exports_) {
            module_name = exports_->module_name;
        } else if (has_data_directory(directory_entry::EXPORT)) {
            // Try to get module name from exports without triggering full parse
            auto exp = exports();
            if (exp) {
                module_name = exp->module_name;
            }
        }
        check_import_anomalies(*imports_, module_name);
    } catch (const std::exception& e) {
        // If parsing fails, return empty import directory
        // (allows graceful handling of malformed imports)
        imports_ = std::make_shared<import_directory>();
    }

    return imports_;
}

std::shared_ptr<export_directory> pe_file::exports() const {
    // Lazy parsing: only parse exports on first access
    if (exports_) {
        return exports_;
    }

    // Check if export directory exists
    if (!has_data_directory(directory_entry::EXPORT)) {
        // Return empty export directory
        exports_ = std::make_shared<export_directory>();
        return exports_;
    }

    // Get export directory location
    uint32_t export_rva = data_directory_rva(directory_entry::EXPORT);
    uint32_t export_size = data_directory_size(directory_entry::EXPORT);

    // Parse export directory
    try {
        auto parsed = export_directory_parser::parse(
            data_,
            sections_,
            export_rva,
            export_size
        );
        exports_ = std::make_shared<export_directory>(std::move(parsed));

        // Check for export anomalies
        check_export_anomalies(*exports_);
    } catch (const std::exception& e) {
        // If parsing fails, return empty export directory
        // (allows graceful handling of malformed exports)
        exports_ = std::make_shared<export_directory>();
    }

    return exports_;
}

std::shared_ptr<base_relocation_directory> pe_file::relocations() const {
    // Lazy parsing: only parse relocations on first access
    if (relocations_) {
        return relocations_;
    }

    // Check if base relocation directory exists
    if (!has_data_directory(directory_entry::BASERELOC)) {
        // Return empty relocation directory
        relocations_ = std::make_shared<base_relocation_directory>();
        return relocations_;
    }

    // Get relocation directory location
    uint32_t reloc_rva = data_directory_rva(directory_entry::BASERELOC);
    uint32_t reloc_size = data_directory_size(directory_entry::BASERELOC);

    // Parse relocation directory
    try {
        auto parsed = base_relocation_parser::parse(
            data_,
            sections_,
            reloc_rva,
            reloc_size
        );
        relocations_ = std::make_shared<base_relocation_directory>(std::move(parsed));

        // Check for unusual relocation types and header targeting
        check_relocation_anomalies(*relocations_);
    } catch (const std::exception& e) {
        // If parsing fails, return empty relocation directory
        // (allows graceful handling of malformed relocations)
        relocations_ = std::make_shared<base_relocation_directory>();
    }

    return relocations_;
}

std::shared_ptr<tls_directory> pe_file::tls() const {
    // Lazy parsing: only parse TLS directory on first access
    if (tls_) {
        return tls_;
    }

    // Check if TLS directory exists
    if (!has_data_directory(directory_entry::TLS)) {
        // Return empty TLS directory
        tls_ = std::make_shared<tls_directory>();
        return tls_;
    }

    // Get TLS directory location
    uint32_t tls_rva = data_directory_rva(directory_entry::TLS);
    uint32_t tls_size = data_directory_size(directory_entry::TLS);

    // Parse TLS directory
    try {
        auto parsed = tls_directory_parser::parse(
            data_,
            sections_,
            tls_rva,
            tls_size,
            is_64bit_,
            image_base_
        );
        tls_ = std::make_shared<tls_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty TLS directory
        // (allows graceful handling of malformed TLS)
        tls_ = std::make_shared<tls_directory>();
    }

    return tls_;
}

std::shared_ptr<debug_directory> pe_file::debug() const {
    // Lazy parsing: only parse debug directory on first access
    if (debug_) {
        return debug_;
    }

    // Check if debug directory exists
    if (!has_data_directory(directory_entry::DEBUG)) {
        // Return empty debug directory
        debug_ = std::make_shared<debug_directory>();
        return debug_;
    }

    // Get debug directory location
    uint32_t debug_rva = data_directory_rva(directory_entry::DEBUG);
    uint32_t debug_size = data_directory_size(directory_entry::DEBUG);

    // Parse debug directory
    try {
        auto parsed = debug_directory_parser::parse(
            data_,
            sections_,
            debug_rva,
            debug_size
        );
        debug_ = std::make_shared<debug_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty debug directory
        // (allows graceful handling of malformed debug info)
        debug_ = std::make_shared<debug_directory>();
    }

    return debug_;
}

std::shared_ptr<load_config_directory> pe_file::load_config() const {
    // Lazy parsing: only parse load config directory on first access
    if (load_config_) {
        return load_config_;
    }

    // Check if load config directory exists
    if (!has_data_directory(directory_entry::LOAD_CONFIG)) {
        // Return empty load config directory
        load_config_ = std::make_shared<load_config_directory>();
        return load_config_;
    }

    // Get load config directory location
    uint32_t load_config_rva = data_directory_rva(directory_entry::LOAD_CONFIG);
    uint32_t load_config_size = data_directory_size(directory_entry::LOAD_CONFIG);

    // Parse load config directory
    try {
        auto parsed = load_config_directory_parser::parse(
            data_,
            sections_,
            load_config_rva,
            load_config_size,
            is_64bit_
        );
        load_config_ = std::make_shared<load_config_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty load config directory
        // (allows graceful handling of malformed load config)
        load_config_ = std::make_shared<load_config_directory>();
    }

    return load_config_;
}

std::shared_ptr<exception_directory> pe_file::exceptions() const {
    // Lazy parsing: only parse exception directory on first access
    if (exceptions_) {
        return exceptions_;
    }

    // Check if exception directory exists
    if (!has_data_directory(directory_entry::EXCEPTION)) {
        // Return empty exception directory
        exceptions_ = std::make_shared<exception_directory>();
        return exceptions_;
    }

    // Get exception directory location
    uint32_t exception_rva = data_directory_rva(directory_entry::EXCEPTION);
    uint32_t exception_size = data_directory_size(directory_entry::EXCEPTION);

    // Parse exception directory
    try {
        auto parsed = exception_directory_parser::parse(
            data_,
            sections_,
            exception_rva,
            exception_size,
            is_64bit_
        );
        exceptions_ = std::make_shared<exception_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty exception directory
        // (allows graceful handling of malformed exception directory)
        exceptions_ = std::make_shared<exception_directory>();
    }

    return exceptions_;
}

std::shared_ptr<delay_import_directory> pe_file::delay_imports() const {
    // Lazy parsing: only parse delay import directory on first access
    if (delay_imports_) {
        return delay_imports_;
    }

    // Check if delay import directory exists
    if (!has_data_directory(directory_entry::DELAY_IMPORT)) {
        // Return empty delay import directory
        delay_imports_ = std::make_shared<delay_import_directory>();
        return delay_imports_;
    }

    // Get delay import directory location
    uint32_t delay_import_rva = data_directory_rva(directory_entry::DELAY_IMPORT);
    uint32_t delay_import_size = data_directory_size(directory_entry::DELAY_IMPORT);

    // Parse delay import directory
    try {
        auto parsed = delay_import_directory_parser::parse(
            data_,
            sections_,
            delay_import_rva,
            delay_import_size,
            is_64bit_,
            image_base_
        );
        delay_imports_ = std::make_shared<delay_import_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty delay import directory
        // (allows graceful handling of malformed delay imports)
        delay_imports_ = std::make_shared<delay_import_directory>();
    }

    return delay_imports_;
}

std::shared_ptr<bound_import_directory> pe_file::bound_imports() const {
    // Lazy parsing: only parse bound import directory on first access
    if (bound_imports_) {
        return bound_imports_;
    }

    // Check if bound import directory exists
    if (!has_data_directory(directory_entry::BOUND_IMPORT)) {
        // Return empty bound import directory
        bound_imports_ = std::make_shared<bound_import_directory>();
        return bound_imports_;
    }

    // Get bound import directory location
    uint32_t bound_import_rva = data_directory_rva(directory_entry::BOUND_IMPORT);
    uint32_t bound_import_size = data_directory_size(directory_entry::BOUND_IMPORT);

    // Parse bound import directory
    try {
        auto parsed = bound_import_directory_parser::parse(
            data_,
            sections_,
            bound_import_rva,
            bound_import_size
        );
        bound_imports_ = std::make_shared<bound_import_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty bound import directory
        // (allows graceful handling of malformed bound imports)
        bound_imports_ = std::make_shared<bound_import_directory>();
    }

    return bound_imports_;
}

std::shared_ptr<security_directory> pe_file::security() const {
    // Lazy parsing: only parse security directory on first access
    if (security_) {
        return security_;
    }

    // Check if security directory exists
    if (!has_data_directory(directory_entry::SECURITY)) {
        // Return empty security directory
        security_ = std::make_shared<security_directory>();
        return security_;
    }

    // IMPORTANT: Unlike other data directories, the "RVA" field for security
    // directory is actually a FILE OFFSET, not an RVA!
    uint32_t security_offset = data_directory_rva(directory_entry::SECURITY);
    uint32_t security_size = data_directory_size(directory_entry::SECURITY);

    // Parse security directory
    try {
        auto parsed = security_directory_parser::parse(
            data_,
            security_offset,  // This is a file offset, not an RVA!
            security_size
        );
        security_ = std::make_shared<security_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty security directory
        // (allows graceful handling of malformed certificates)
        security_ = std::make_shared<security_directory>();
    }

    return security_;
}

std::shared_ptr<com_descriptor> pe_file::clr_header() const {
    // Lazy parsing: only parse COM descriptor on first access
    if (com_descriptor_) {
        return com_descriptor_;
    }

    // Check if COM descriptor exists
    if (!has_data_directory(directory_entry::COM_DESCRIPTOR)) {
        // Return empty COM descriptor (non-.NET executable)
        com_descriptor_ = std::make_shared<com_descriptor>();
        return com_descriptor_;
    }

    // Get COM descriptor location
    uint32_t com_descriptor_rva = data_directory_rva(directory_entry::COM_DESCRIPTOR);
    uint32_t com_descriptor_size = data_directory_size(directory_entry::COM_DESCRIPTOR);

    // Parse COM descriptor
    try {
        auto parsed = com_descriptor_parser::parse(
            data_,
            sections_,
            com_descriptor_rva,
            com_descriptor_size
        );
        com_descriptor_ = std::make_shared<com_descriptor>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty COM descriptor
        // (allows graceful handling of malformed .NET metadata)
        com_descriptor_ = std::make_shared<com_descriptor>();
    }

    return com_descriptor_;
}

std::shared_ptr<iat_directory> pe_file::import_address_table() const {
    // Lazy parsing: only parse IAT on first access
    if (iat_) {
        return iat_;
    }

    // Check if IAT exists
    if (!has_data_directory(directory_entry::IAT)) {
        // Return empty IAT (no data directory)
        iat_ = std::make_shared<iat_directory>();
        return iat_;
    }

    // Get IAT location
    uint32_t iat_rva = data_directory_rva(directory_entry::IAT);
    uint32_t iat_size = data_directory_size(directory_entry::IAT);

    // Parse IAT
    try {
        auto parsed = iat_directory_parser::parse(
            data_,
            sections_,
            iat_rva,
            iat_size,
            is_64bit_
        );
        iat_ = std::make_shared<iat_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty IAT
        iat_ = std::make_shared<iat_directory>();
    }

    return iat_;
}

std::shared_ptr<global_ptr_directory> pe_file::global_ptr() const {
    // Lazy parsing: only parse global pointer on first access
    if (global_ptr_) {
        return global_ptr_;
    }

    // Check if global pointer exists
    if (!has_data_directory(directory_entry::GLOBALPTR)) {
        // Return empty global pointer (no data directory)
        global_ptr_ = std::make_shared<global_ptr_directory>();
        return global_ptr_;
    }

    // Get global pointer value from data directory
    // Note: Unlike other directories, the RVA field itself IS the global pointer value
    uint32_t global_ptr_rva = data_directory_rva(directory_entry::GLOBALPTR);
    uint32_t global_ptr_size = data_directory_size(directory_entry::GLOBALPTR);

    // Parse global pointer (simple - just extract RVA)
    auto parsed = global_ptr_directory_parser::parse(global_ptr_rva, global_ptr_size);
    global_ptr_ = std::make_shared<global_ptr_directory>(std::move(parsed));

    return global_ptr_;
}

std::shared_ptr<architecture_directory> pe_file::architecture() const {
    // Lazy parsing: only parse architecture directory on first access
    if (architecture_) {
        return architecture_;
    }

    // Get architecture directory values from data directory
    // Note: According to PE/COFF spec, both RVA and size should be zero (reserved)
    uint32_t arch_rva = data_directory_rva(directory_entry::ARCHITECTURE);
    uint32_t arch_size = data_directory_size(directory_entry::ARCHITECTURE);

    // Parse architecture directory (simple - just extract RVA and size for validation)
    auto parsed = architecture_directory_parser::parse(arch_rva, arch_size);
    architecture_ = std::make_shared<architecture_directory>(std::move(parsed));

    return architecture_;
}

std::shared_ptr<reserved_directory> pe_file::reserved() const {
    // Lazy parsing: only parse reserved directory on first access
    if (reserved_) {
        return reserved_;
    }

    // Get reserved directory values from data directory
    // Note: According to PE/COFF spec, both RVA and size must be zero (reserved)
    uint32_t reserved_rva = data_directory_rva(directory_entry::RESERVED);
    uint32_t reserved_size = data_directory_size(directory_entry::RESERVED);

    // Parse reserved directory (simple - just extract RVA and size for validation)
    auto parsed = reserved_directory_parser::parse(reserved_rva, reserved_size);
    reserved_ = std::make_shared<reserved_directory>(std::move(parsed));

    return reserved_;
}

// =============================================================================
// Rich Header Access
// =============================================================================

std::optional<rich_header> pe_file::rich() const {
    // Lazy parsing: only parse Rich header on first access
    if (rich_header_parsed_) {
        return rich_header_;
    }

    rich_header_parsed_ = true;

    // Parse Rich header (located between DOS stub and PE header)
    rich_header_ = rich_header_parser::parse(data_, pe_offset_);

    return rich_header_;
}

bool pe_file::has_rich_header() const {
    // Check if Rich header exists without fully parsing it
    return rich_header_parser::has_rich_header(data_, pe_offset_);
}

// =============================================================================
// Diagnostics
// =============================================================================

const diagnostic_collector& pe_file::diagnostics() const {
    return diagnostics_;
}

bool pe_file::has_diagnostic(diagnostic_code code) const {
    return diagnostics_.has_code(code);
}

bool pe_file::has_anomalies() const {
    return diagnostics_.has_anomalies();
}

bool pe_file::has_parse_errors() const {
    return diagnostics_.has_errors();
}

// =============================================================================
// Security Analysis (ASLR/DEP/CFG/etc.)
// =============================================================================

bool pe_file::has_aslr() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::DYNAMIC_BASE)) != 0;
}

bool pe_file::has_high_entropy_aslr() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::HIGH_ENTROPY_VA)) != 0;
}

bool pe_file::has_dep() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::NX_COMPAT)) != 0;
}

bool pe_file::has_cfg() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::GUARD_CF)) != 0;
}

bool pe_file::has_no_seh() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::NO_SEH)) != 0;
}

bool pe_file::has_safe_seh() const {
    // SafeSEH is only applicable to 32-bit PE files
    if (is_64bit_) {
        return false;
    }

    // Check load config directory for SEHandlerTable
    auto lc = load_config();
    if (!lc) {
        return false;
    }

    // SafeSEH is enabled if SEHandlerTable and SEHandlerCount are non-zero
    return lc->se_handler_table != 0 && lc->se_handler_count > 0;
}

bool pe_file::has_authenticode() const {
    return has_data_directory(directory_entry::SECURITY) &&
           data_directory_size(directory_entry::SECURITY) > 0;
}

bool pe_file::is_dotnet() const {
    return has_data_directory(directory_entry::COM_DESCRIPTOR) &&
           data_directory_size(directory_entry::COM_DESCRIPTOR) > 0;
}

bool pe_file::has_force_integrity() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::FORCE_INTEGRITY)) != 0;
}

bool pe_file::is_appcontainer() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::APPCONTAINER)) != 0;
}

bool pe_file::is_terminal_server_aware() const {
    return (dll_characteristics_ & static_cast<uint16_t>(pe_dll_characteristics::TERMINAL_SERVER_AWARE)) != 0;
}

bool pe_file::is_dll() const {
    return (characteristics_ & static_cast<uint16_t>(pe_file_characteristics::DLL)) != 0;
}

bool pe_file::is_large_address_aware() const {
    return (characteristics_ & static_cast<uint16_t>(pe_file_characteristics::LARGE_ADDRESS_AWARE)) != 0;
}

// =============================================================================
// Subsystem Detection
// =============================================================================

bool pe_file::is_gui() const {
    return subsystem_ == static_cast<uint16_t>(pe_subsystem::WINDOWS_GUI);
}

bool pe_file::is_console() const {
    return subsystem_ == static_cast<uint16_t>(pe_subsystem::WINDOWS_CUI);
}

bool pe_file::is_native() const {
    return subsystem_ == static_cast<uint16_t>(pe_subsystem::NATIVE) ||
           subsystem_ == static_cast<uint16_t>(pe_subsystem::NATIVE_WINDOWS);
}

bool pe_file::is_efi() const {
    return subsystem_ == static_cast<uint16_t>(pe_subsystem::EFI_APPLICATION) ||
           subsystem_ == static_cast<uint16_t>(pe_subsystem::EFI_BOOT_SERVICE_DRIVER) ||
           subsystem_ == static_cast<uint16_t>(pe_subsystem::EFI_RUNTIME_DRIVER) ||
           subsystem_ == static_cast<uint16_t>(pe_subsystem::EFI_ROM);
}

// =============================================================================
// Import/Export Analysis
// =============================================================================

std::vector<std::string> pe_file::imported_dlls() const {
    auto imp = imports();
    if (!imp) {
        return {};
    }

    std::vector<std::string> dll_names;
    dll_names.reserve(imp->dlls.size());
    for (const auto& dll : imp->dlls) {
        dll_names.push_back(dll.name);
    }
    return dll_names;
}

size_t pe_file::imported_function_count() const {
    auto imp = imports();
    if (!imp) {
        return 0;
    }
    return imp->total_imports();
}

bool pe_file::imports_dll(std::string_view dll_name) const {
    auto imp = imports();
    if (!imp) {
        return false;
    }

    // Case-insensitive comparison
    auto to_lower = [](std::string s) {
        for (auto& c : s) {
            c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        }
        return s;
    };

    std::string target = to_lower(std::string(dll_name));
    for (const auto& dll : imp->dlls) {
        if (to_lower(dll.name) == target) {
            return true;
        }
    }
    return false;
}

bool pe_file::imports_function(std::string_view function_name) const {
    auto imp = imports();
    if (!imp) {
        return false;
    }

    for (const auto& dll : imp->dlls) {
        for (const auto& func : dll.functions) {
            if (func.name == function_name) {
                return true;
            }
        }
    }
    return false;
}

bool pe_file::imports_function(std::string_view dll_name, std::string_view function_name) const {
    auto imp = imports();
    if (!imp) {
        return false;
    }

    // Case-insensitive DLL comparison
    auto to_lower = [](std::string s) {
        for (auto& c : s) {
            c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        }
        return s;
    };

    std::string target_dll = to_lower(std::string(dll_name));
    for (const auto& dll : imp->dlls) {
        if (to_lower(dll.name) == target_dll) {
            for (const auto& func : dll.functions) {
                if (func.name == function_name) {
                    return true;
                }
            }
        }
    }
    return false;
}

std::vector<std::string> pe_file::exported_functions() const {
    auto exp = exports();
    if (!exp) {
        return {};
    }
    return exp->get_export_names();
}

size_t pe_file::exported_function_count() const {
    auto exp = exports();
    if (!exp) {
        return 0;
    }
    return exp->export_count();
}

bool pe_file::exports_function(std::string_view function_name) const {
    auto exp = exports();
    if (!exp) {
        return false;
    }
    return exp->find_export(function_name) != nullptr;
}

// =============================================================================
// Entropy Analysis (Packing Detection)
// =============================================================================

double pe_file::file_entropy() const {
    return entropy_calculator::calculate(data_);
}

double pe_file::section_entropy(const std::string& section_name) const {
    auto sec = find_section(section_name);
    if (!sec || sec->data.empty()) {
        return 0.0;
    }
    return entropy_calculator::calculate(sec->data);
}

std::vector<std::pair<std::string, double>> pe_file::all_section_entropies() const {
    std::vector<std::pair<std::string, double>> result;
    result.reserve(sections_.size());

    for (const auto& section : sections_) {
        double entropy = 0.0;
        if (!section.data.empty()) {
            entropy = entropy_calculator::calculate(section.data);
        }
        result.emplace_back(section.name, entropy);
    }

    return result;
}

bool pe_file::has_high_entropy_sections() const {
    for (const auto& section : sections_) {
        if (!section.data.empty()) {
            double entropy = entropy_calculator::calculate(section.data);
            if (entropy >= entropy_calculator::HIGH_ENTROPY_THRESHOLD) {
                return true;
            }
        }
    }
    return false;
}

bool pe_file::is_likely_packed() const {
    // Heuristic: Check for signs of packing
    // 1. High entropy in code section
    // 2. Few imports (packers often resolve imports dynamically)
    // 3. Entry point in unusual section
    // 4. Suspicious section names (UPX, ASPack, etc.)

    // Check for high entropy in executable sections
    int high_entropy_exec_sections = 0;
    for (const auto& section : sections_) {
        if (section.is_executable() && !section.data.empty()) {
            double entropy = entropy_calculator::calculate(section.data);
            if (entropy >= entropy_calculator::HIGH_ENTROPY_THRESHOLD) {
                high_entropy_exec_sections++;
            }
        }
    }

    // Check for very few imports (typical of packed executables)
    auto imp = imports();
    bool few_imports = !imp || imp->total_imports() < 10;

    // Check for suspicious section names
    bool suspicious_names = false;
    static const char* packer_names[] = {
        "UPX", ".upx", "UPX0", "UPX1", "UPX2",
        ".aspack", "ASPack", ".adata",
        ".packed", ".PACKER", "pec",
        ".petite", "PEtite",
        ".nsp", "NSP",
        ".FSG", "FSG!",
        ".MEW", ".mew",
        ".yP", "yP",
        ".MPRESS", "MPRESS1", "MPRESS2",
        ".Themida", ".VMProtect",
        nullptr
    };

    for (const auto& section : sections_) {
        for (const char** name = packer_names; *name != nullptr; ++name) {
            if (section.name.find(*name) != std::string::npos) {
                suspicious_names = true;
                break;
            }
        }
        if (suspicious_names) break;
    }

    // Heuristic scoring
    int score = 0;
    if (high_entropy_exec_sections > 0) score += 2;
    if (few_imports) score += 1;
    if (suspicious_names) score += 2;

    return score >= 2;
}

// =============================================================================
// Overlay Detection
// =============================================================================

bool pe_file::has_overlay() const {
    if (!overlay_parsed_) {
        overlay_info_ = overlay_detector::detect(
            data_, pe_offset_, section_count_, optional_header_size_
        );
        overlay_parsed_ = true;
    }
    return overlay_info_.exists();
}

uint64_t pe_file::overlay_offset() const {
    if (!overlay_parsed_) {
        (void)has_overlay();  // Trigger lazy parsing
    }
    return overlay_info_.offset;
}

uint64_t pe_file::overlay_size() const {
    if (!overlay_parsed_) {
        (void)has_overlay();  // Trigger lazy parsing
    }
    return overlay_info_.size;
}

std::span<const uint8_t> pe_file::overlay_data() const {
    if (!has_overlay()) {
        return {};
    }
    return overlay_detector::view(data_, overlay_info_);
}

double pe_file::overlay_entropy() const {
    if (!overlay_parsed_) {
        (void)has_overlay();  // Trigger lazy parsing
    }
    return overlay_info_.entropy;
}

} // namespace libexe
