// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/pe_file.hpp>
#include "ImageDosHeader.hh"  // Generated by DataScript
#include <fstream>
#include <stdexcept>
#include <cstring>
#include <algorithm>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
pe_file pe_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

pe_file pe_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS stub + PE header pointer
        throw std::runtime_error("File too small to be a valid PE executable");
    }

    pe_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_pe_headers();
        file.parse_sections();
    } catch (const libexe::format::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid PE file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing PE file: ") + e.what());
    }

    return file;
}

void pe_file::parse_pe_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Parse DOS header to get e_lfanew (offset to PE header)
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);

    if (dos_header.e_magic != libexe::format::DOS_SIGNATURE) {
        throw std::runtime_error("Not a valid DOS/PE file (invalid MZ signature)");
    }

    // Get offset to PE header
    pe_offset_ = dos_header.e_lfanew;
    if (pe_offset_ == 0 || pe_offset_ >= data_.size() - 4) {
        throw std::runtime_error("Not a PE file (e_lfanew invalid)");
    }

    // Verify PE signature "PE\0\0"
    ptr = data_.data() + pe_offset_;
    uint32_t pe_sig = libexe::format::read_uint32_le(ptr, end);
    if (pe_sig != libexe::format::PE_SIGNATURE) {
        throw std::runtime_error("Not a PE file (invalid PE signature)");
    }

    // Parse COFF File Header
    auto coff_header = libexe::format::ImageFileHeader::read(ptr, end);
    machine_type_ = static_cast<uint16_t>(coff_header.Machine);
    section_count_ = coff_header.NumberOfSections;
    timestamp_ = coff_header.TimeDateStamp;
    characteristics_ = static_cast<uint16_t>(coff_header.Characteristics);

    // Parse Optional Header
    optional_header_offset_ = static_cast<uint32_t>(ptr - data_.data());

    // Read magic to determine PE32 vs PE32+
    if (ptr + 2 > end) {
        throw std::runtime_error("PE file truncated (no optional header magic)");
    }

    uint16_t magic = libexe::format::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind for full header parse

    if (magic == libexe::format::PE32_MAGIC) {
        // PE32 (32-bit)
        is_64bit_ = false;
        auto opt_header = libexe::format::ImageOptionalHeader32::read(ptr, end);

        image_base_ = opt_header.ImageBase;
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

    } else if (magic == libexe::format::PE32PLUS_MAGIC) {
        // PE32+ (64-bit)
        is_64bit_ = true;
        auto opt_header = libexe::format::ImageOptionalHeader64::read(ptr, end);

        image_base_ = static_cast<uint32_t>(opt_header.ImageBase & 0xFFFFFFFF);  // Truncate for API
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

    } else {
        throw std::runtime_error("Invalid PE optional header magic: " + std::to_string(magic));
    }
}

void pe_file::parse_sections() {
    // Section headers start after optional header
    // We need to get the optional header size from the COFF header
    const uint8_t* ptr = data_.data() + pe_offset_ + 4;  // Skip PE signature
    const uint8_t* end = data_.data() + data_.size();

    // Re-parse COFF header to get optional header size
    auto coff_header = libexe::format::ImageFileHeader::read(ptr, end);
    uint16_t opt_hdr_size = coff_header.SizeOfOptionalHeader;

    // ptr is now at the start of the optional header, skip it
    ptr += opt_hdr_size;

    // Parse each section header
    for (uint16_t i = 0; i < section_count_; i++) {
        if (ptr + 40 > end) break;  // Section header is 40 bytes

        auto section_header = libexe::format::ImageSectionHeader::read(ptr, end);

        pe_section section;

        // Extract section name (8 bytes, may not be null-terminated)
        section.name = std::string(reinterpret_cast<const char*>(section_header.Name.data()),
                                   std::find(reinterpret_cast<const char*>(section_header.Name.data()),
                                            reinterpret_cast<const char*>(section_header.Name.data() + 8), '\0'));

        section.virtual_address = section_header.VirtualAddress;
        section.virtual_size = section_header.VirtualSize;
        section.raw_data_offset = section_header.PointerToRawData;
        section.raw_data_size = section_header.SizeOfRawData;
        section.characteristics = static_cast<pe_section_characteristics>(section_header.Characteristics);

        // Create span for section data
        if (section.raw_data_offset > 0 &&
            section.raw_data_offset < data_.size() &&
            section.raw_data_size > 0) {

            size_t available = data_.size() - section.raw_data_offset;
            size_t actual_size = std::min(static_cast<size_t>(section.raw_data_size), available);

            section.data = std::span<const uint8_t>(
                data_.data() + section.raw_data_offset,
                actual_size
            );
        }

        sections_.push_back(std::move(section));
    }
}

// Interface implementation
format_type pe_file::get_format() const {
    return is_64bit_ ? format_type::PE_PLUS_WIN64 : format_type::PE_WIN32;
}

std::string_view pe_file::format_name() const {
    return is_64bit_ ? "PE32+ (64-bit Windows)" : "PE32 (32-bit Windows)";
}

std::span<const uint8_t> pe_file::code_section() const {
    auto code_sec = get_code_section();
    if (code_sec) {
        return code_sec->data;
    }
    return {};
}

// PE-specific accessors
bool pe_file::is_64bit() const {
    return is_64bit_;
}

pe_machine_type pe_file::machine_type() const {
    return static_cast<pe_machine_type>(machine_type_);
}

uint16_t pe_file::section_count() const {
    return section_count_;
}

uint32_t pe_file::timestamp() const {
    return timestamp_;
}

pe_file_characteristics pe_file::characteristics() const {
    return static_cast<pe_file_characteristics>(characteristics_);
}

uint32_t pe_file::image_base() const {
    return image_base_;
}

uint32_t pe_file::entry_point_rva() const {
    return entry_point_rva_;
}

uint32_t pe_file::section_alignment() const {
    return section_alignment_;
}

uint32_t pe_file::file_alignment() const {
    return file_alignment_;
}

uint32_t pe_file::size_of_image() const {
    return size_of_image_;
}

uint32_t pe_file::size_of_headers() const {
    return size_of_headers_;
}

pe_subsystem pe_file::subsystem() const {
    return static_cast<pe_subsystem>(subsystem_);
}

pe_dll_characteristics pe_file::dll_characteristics() const {
    return static_cast<pe_dll_characteristics>(dll_characteristics_);
}

const std::vector<pe_section>& pe_file::sections() const {
    return sections_;
}

std::optional<pe_section> pe_file::find_section(const std::string& name) const {
    for (const auto& section : sections_) {
        if (section.name == name) {
            return section;
        }
    }
    return std::nullopt;
}

std::optional<pe_section> pe_file::get_code_section() const {
    // Try common code section names
    auto text_sec = find_section(".text");
    if (text_sec) return text_sec;

    auto code_sec = find_section("CODE");
    if (code_sec) return code_sec;

    // If not found by name, return first executable section
    for (const auto& section : sections_) {
        if (has_flag(section.characteristics, pe_section_characteristics::MEM_EXECUTE)) {
            return section;
        }
    }

    return std::nullopt;
}

} // namespace libexe
