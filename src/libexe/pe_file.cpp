// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/pe_file.hpp>
#include <libexe/pe_section_parser.hpp>
#include <libexe/resources/pe_resource_directory.hpp>
#include <libexe/parsers/import_directory_parser.hpp>
#include <libexe/parsers/export_directory_parser.hpp>
#include <libexe/parsers/base_relocation_parser.hpp>
#include <libexe/parsers/tls_directory_parser.hpp>
#include <libexe/parsers/debug_directory_parser.hpp>
#include <libexe/parsers/load_config_directory_parser.hpp>
#include <libexe/parsers/exception_directory_parser.hpp>
#include <libexe/parsers/delay_import_directory_parser.hpp>
#include <libexe/parsers/bound_import_directory_parser.hpp>
#include <libexe/parsers/security_directory_parser.hpp>
#include <libexe/parsers/com_descriptor_parser.hpp>
#include <libexe/parsers/iat_directory_parser.hpp>
#include <libexe/parsers/global_ptr_directory_parser.hpp>
#include <libexe/parsers/architecture_directory_parser.hpp>
#include <libexe/parsers/reserved_directory_parser.hpp>
#include <libexe/import_directory.hpp>
#include <libexe/export_directory.hpp>
#include <libexe/base_relocation.hpp>
#include <libexe/tls_directory.hpp>
#include <libexe/debug_directory.hpp>
#include <libexe/load_config_directory.hpp>
#include <libexe/exception_directory.hpp>
#include <libexe/delay_import_directory.hpp>
#include <libexe/bound_import_directory.hpp>
#include <libexe/security_directory.hpp>
#include <libexe/com_descriptor.hpp>
#include <libexe/iat_directory.hpp>
#include <libexe/global_ptr_directory.hpp>
#include <libexe/architecture_directory.hpp>
#include <libexe/reserved_directory.hpp>
#include "libexe_format_mz.hh"  // Generated by DataScript (modular)
#include "libexe_format_pe.hh"  // Generated by DataScript (modular)
#include <fstream>
#include <stdexcept>
#include <cstring>
#include <algorithm>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
pe_file pe_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

pe_file pe_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS stub + PE header pointer
        throw std::runtime_error("File too small to be a valid PE executable");
    }

    pe_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_pe_headers();
        file.parse_sections();
    } catch (const formats::pe::pe_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid PE file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing PE file: ") + e.what());
    }

    return file;
}

void pe_file::parse_pe_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Parse DOS header to get e_lfanew (offset to PE header)
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);

    if (dos_header.e_magic != 0x5A4D) {
        throw std::runtime_error("Not a valid DOS/PE file (invalid MZ signature)");
    }

    // Get offset to PE header
    pe_offset_ = dos_header.e_lfanew;
    if (pe_offset_ == 0 || pe_offset_ >= data_.size() - 4) {
        throw std::runtime_error("Not a PE file (e_lfanew invalid)");
    }

    // Verify PE signature "PE\0\0"
    ptr = data_.data() + pe_offset_;
    uint32_t pe_sig = formats::pe::pe_header::read_uint32_le(ptr, end);
    if (pe_sig != 0x00004550) {
        throw std::runtime_error("Not a PE file (invalid PE signature)");
    }

    // Parse COFF File Header
    auto coff_header = formats::pe::pe_header::image_file_header::read(ptr, end);
    machine_type_ = static_cast<uint16_t>(coff_header.Machine);
    section_count_ = coff_header.NumberOfSections;
    timestamp_ = coff_header.TimeDateStamp;
    characteristics_ = static_cast<uint16_t>(coff_header.Characteristics);

    // Parse Optional Header
    optional_header_offset_ = static_cast<uint32_t>(ptr - data_.data());

    // Read magic to determine PE32 vs PE32+
    if (ptr + 2 > end) {
        throw std::runtime_error("PE file truncated (no optional header magic)");
    }

    uint16_t magic = formats::pe::pe_header::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind for full header parse

    if (magic == 0x010B) {
        // PE32 (32-bit)
        is_64bit_ = false;
        auto opt_header = formats::pe::pe_header::image_optional_header32::read(ptr, end);

        image_base_ = opt_header.ImageBase;
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

        // Extract data directories
        for (size_t i = 0; i < opt_header.DataDirectory.size() && i < 16; i++) {
            data_directories_[i].rva = opt_header.DataDirectory[i].VirtualAddress;
            data_directories_[i].size = opt_header.DataDirectory[i].Size;
        }

    } else if (magic == 0x020B) {
        // PE32+ (64-bit)
        is_64bit_ = true;
        auto opt_header = formats::pe::pe_header::image_optional_header64::read(ptr, end);

        image_base_ = opt_header.ImageBase;
        entry_point_rva_ = opt_header.AddressOfEntryPoint;
        section_alignment_ = opt_header.SectionAlignment;
        file_alignment_ = opt_header.FileAlignment;
        size_of_image_ = opt_header.SizeOfImage;
        size_of_headers_ = opt_header.SizeOfHeaders;
        subsystem_ = static_cast<uint16_t>(opt_header.Subsystem);
        dll_characteristics_ = static_cast<uint16_t>(opt_header.DllCharacteristics);

        // Extract data directories
        for (size_t i = 0; i < opt_header.DataDirectory.size() && i < 16; i++) {
            data_directories_[i].rva = opt_header.DataDirectory[i].VirtualAddress;
            data_directories_[i].size = opt_header.DataDirectory[i].Size;
        }

    } else {
        throw std::runtime_error("Invalid PE optional header magic: " + std::to_string(magic));
    }
}

void pe_file::parse_sections() {
    // Get optional header size from COFF header
    const uint8_t* ptr = data_.data() + pe_offset_ + 4;  // Skip PE signature
    const uint8_t* end = data_.data() + data_.size();

    auto coff_header = formats::pe::pe_header::image_file_header::read(ptr, end);
    uint16_t opt_hdr_size = coff_header.SizeOfOptionalHeader;

    // Use pe_section_parser for consistent section parsing
    sections_ = pe_section_parser::parse_sections(
        data_,
        pe_offset_,
        section_count_,
        opt_hdr_size
    );
}

// Interface implementation
format_type pe_file::get_format() const {
    return is_64bit_ ? format_type::PE_PLUS_WIN64 : format_type::PE_WIN32;
}

std::string_view pe_file::format_name() const {
    return is_64bit_ ? "PE32+ (64-bit Windows)" : "PE32 (32-bit Windows)";
}

std::span<const uint8_t> pe_file::code_section() const {
    auto code_sec = get_code_section();
    if (code_sec) {
        return code_sec->data;
    }
    return {};
}

// PE-specific accessors
bool pe_file::is_64bit() const {
    return is_64bit_;
}

pe_machine_type pe_file::machine_type() const {
    return static_cast<pe_machine_type>(machine_type_);
}

uint16_t pe_file::section_count() const {
    return section_count_;
}

uint32_t pe_file::timestamp() const {
    return timestamp_;
}

pe_file_characteristics pe_file::characteristics() const {
    return static_cast<pe_file_characteristics>(characteristics_);
}

uint64_t pe_file::image_base() const {
    return image_base_;
}

uint32_t pe_file::entry_point_rva() const {
    return entry_point_rva_;
}

uint32_t pe_file::section_alignment() const {
    return section_alignment_;
}

uint32_t pe_file::file_alignment() const {
    return file_alignment_;
}

uint32_t pe_file::size_of_image() const {
    return size_of_image_;
}

uint32_t pe_file::size_of_headers() const {
    return size_of_headers_;
}

pe_subsystem pe_file::subsystem() const {
    return static_cast<pe_subsystem>(subsystem_);
}

pe_dll_characteristics pe_file::dll_characteristics() const {
    return static_cast<pe_dll_characteristics>(dll_characteristics_);
}

const std::vector<pe_section>& pe_file::sections() const {
    return sections_;
}

std::optional<pe_section> pe_file::find_section(const std::string& name) const {
    for (const auto& section : sections_) {
        if (section.name == name) {
            return section;
        }
    }
    return std::nullopt;
}

std::optional<pe_section> pe_file::get_code_section() const {
    // Try common code section names
    auto text_sec = find_section(".text");
    if (text_sec) return text_sec;

    auto code_sec = find_section("CODE");
    if (code_sec) return code_sec;

    // If not found by name, return first executable section
    for (const auto& section : sections_) {
        if (section.is_executable()) {
            return section;
        }
    }

    return std::nullopt;
}

// =============================================================================
// Resource Access
// =============================================================================

bool pe_file::has_resources() const {
    // Check if .rsrc section exists
    return find_section(".rsrc").has_value();
}

std::shared_ptr<resource_directory> pe_file::resources() const {
    auto rsrc_section = find_section(".rsrc");

    if (!rsrc_section) {
        // Return empty resource directory
        return std::make_shared<pe_resource_directory>(std::span<const uint8_t>(), 0);
    }

    // Create PE resource directory from .rsrc section data
    return std::make_shared<pe_resource_directory>(
        rsrc_section->data,
        rsrc_section->virtual_address
    );
}

// =============================================================================
// Data Directory Access
// =============================================================================

uint32_t pe_file::data_directory_rva(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        throw std::out_of_range("Invalid data directory entry: " + std::to_string(index));
    }
    return data_directories_[index].rva;
}

uint32_t pe_file::data_directory_size(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        throw std::out_of_range("Invalid data directory entry: " + std::to_string(index));
    }
    return data_directories_[index].size;
}

bool pe_file::has_data_directory(directory_entry entry) const {
    size_t index = static_cast<size_t>(entry);
    if (index >= 16) {
        return false;
    }

    // Most data directories only need RVA != 0 check
    // Many PE files (especially Corkami test corpus) set size = 0 for variable-length
    // structures like import/export tables that are null-terminated or block-based.
    // The parsers will validate the actual data.

    // Special cases where size MUST be checked:
    // - Security: File offset-based, size is mandatory for certificate data
    // - None currently, but keeping structure for future additions

    // For all other directories: only check RVA != 0
    return data_directories_[index].rva != 0;
}

std::shared_ptr<import_directory> pe_file::imports() const {
    // Lazy parsing: only parse imports on first access
    if (imports_) {
        return imports_;
    }

    // Check if import directory exists
    if (!has_data_directory(directory_entry::IMPORT)) {
        // Return empty import directory
        imports_ = std::make_shared<import_directory>();
        return imports_;
    }

    // Get import directory location
    uint32_t import_rva = data_directory_rva(directory_entry::IMPORT);
    uint32_t import_size = data_directory_size(directory_entry::IMPORT);

    // Parse import directory
    try {
        auto parsed = import_directory_parser::parse(
            data_,
            sections_,
            import_rva,
            import_size,
            is_64bit_
        );
        imports_ = std::make_shared<import_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty import directory
        // (allows graceful handling of malformed imports)
        imports_ = std::make_shared<import_directory>();
    }

    return imports_;
}

std::shared_ptr<export_directory> pe_file::exports() const {
    // Lazy parsing: only parse exports on first access
    if (exports_) {
        return exports_;
    }

    // Check if export directory exists
    if (!has_data_directory(directory_entry::EXPORT)) {
        // Return empty export directory
        exports_ = std::make_shared<export_directory>();
        return exports_;
    }

    // Get export directory location
    uint32_t export_rva = data_directory_rva(directory_entry::EXPORT);
    uint32_t export_size = data_directory_size(directory_entry::EXPORT);

    // Parse export directory
    try {
        auto parsed = export_directory_parser::parse(
            data_,
            sections_,
            export_rva,
            export_size
        );
        exports_ = std::make_shared<export_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty export directory
        // (allows graceful handling of malformed exports)
        exports_ = std::make_shared<export_directory>();
    }

    return exports_;
}

std::shared_ptr<base_relocation_directory> pe_file::relocations() const {
    // Lazy parsing: only parse relocations on first access
    if (relocations_) {
        return relocations_;
    }

    // Check if base relocation directory exists
    if (!has_data_directory(directory_entry::BASERELOC)) {
        // Return empty relocation directory
        relocations_ = std::make_shared<base_relocation_directory>();
        return relocations_;
    }

    // Get relocation directory location
    uint32_t reloc_rva = data_directory_rva(directory_entry::BASERELOC);
    uint32_t reloc_size = data_directory_size(directory_entry::BASERELOC);

    // Parse relocation directory
    try {
        auto parsed = base_relocation_parser::parse(
            data_,
            sections_,
            reloc_rva,
            reloc_size
        );
        relocations_ = std::make_shared<base_relocation_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty relocation directory
        // (allows graceful handling of malformed relocations)
        relocations_ = std::make_shared<base_relocation_directory>();
    }

    return relocations_;
}

std::shared_ptr<tls_directory> pe_file::tls() const {
    // Lazy parsing: only parse TLS directory on first access
    if (tls_) {
        return tls_;
    }

    // Check if TLS directory exists
    if (!has_data_directory(directory_entry::TLS)) {
        // Return empty TLS directory
        tls_ = std::make_shared<tls_directory>();
        return tls_;
    }

    // Get TLS directory location
    uint32_t tls_rva = data_directory_rva(directory_entry::TLS);
    uint32_t tls_size = data_directory_size(directory_entry::TLS);

    // Parse TLS directory
    try {
        auto parsed = tls_directory_parser::parse(
            data_,
            sections_,
            tls_rva,
            tls_size,
            is_64bit_,
            image_base_
        );
        tls_ = std::make_shared<tls_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty TLS directory
        // (allows graceful handling of malformed TLS)
        tls_ = std::make_shared<tls_directory>();
    }

    return tls_;
}

std::shared_ptr<debug_directory> pe_file::debug() const {
    // Lazy parsing: only parse debug directory on first access
    if (debug_) {
        return debug_;
    }

    // Check if debug directory exists
    if (!has_data_directory(directory_entry::DEBUG)) {
        // Return empty debug directory
        debug_ = std::make_shared<debug_directory>();
        return debug_;
    }

    // Get debug directory location
    uint32_t debug_rva = data_directory_rva(directory_entry::DEBUG);
    uint32_t debug_size = data_directory_size(directory_entry::DEBUG);

    // Parse debug directory
    try {
        auto parsed = debug_directory_parser::parse(
            data_,
            sections_,
            debug_rva,
            debug_size
        );
        debug_ = std::make_shared<debug_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty debug directory
        // (allows graceful handling of malformed debug info)
        debug_ = std::make_shared<debug_directory>();
    }

    return debug_;
}

std::shared_ptr<load_config_directory> pe_file::load_config() const {
    // Lazy parsing: only parse load config directory on first access
    if (load_config_) {
        return load_config_;
    }

    // Check if load config directory exists
    if (!has_data_directory(directory_entry::LOAD_CONFIG)) {
        // Return empty load config directory
        load_config_ = std::make_shared<load_config_directory>();
        return load_config_;
    }

    // Get load config directory location
    uint32_t load_config_rva = data_directory_rva(directory_entry::LOAD_CONFIG);
    uint32_t load_config_size = data_directory_size(directory_entry::LOAD_CONFIG);

    // Parse load config directory
    try {
        auto parsed = load_config_directory_parser::parse(
            data_,
            sections_,
            load_config_rva,
            load_config_size,
            is_64bit_
        );
        load_config_ = std::make_shared<load_config_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty load config directory
        // (allows graceful handling of malformed load config)
        load_config_ = std::make_shared<load_config_directory>();
    }

    return load_config_;
}

std::shared_ptr<exception_directory> pe_file::exceptions() const {
    // Lazy parsing: only parse exception directory on first access
    if (exceptions_) {
        return exceptions_;
    }

    // Check if exception directory exists
    if (!has_data_directory(directory_entry::EXCEPTION)) {
        // Return empty exception directory
        exceptions_ = std::make_shared<exception_directory>();
        return exceptions_;
    }

    // Get exception directory location
    uint32_t exception_rva = data_directory_rva(directory_entry::EXCEPTION);
    uint32_t exception_size = data_directory_size(directory_entry::EXCEPTION);

    // Parse exception directory
    try {
        auto parsed = exception_directory_parser::parse(
            data_,
            sections_,
            exception_rva,
            exception_size,
            is_64bit_
        );
        exceptions_ = std::make_shared<exception_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty exception directory
        // (allows graceful handling of malformed exception directory)
        exceptions_ = std::make_shared<exception_directory>();
    }

    return exceptions_;
}

std::shared_ptr<delay_import_directory> pe_file::delay_imports() const {
    // Lazy parsing: only parse delay import directory on first access
    if (delay_imports_) {
        return delay_imports_;
    }

    // Check if delay import directory exists
    if (!has_data_directory(directory_entry::DELAY_IMPORT)) {
        // Return empty delay import directory
        delay_imports_ = std::make_shared<delay_import_directory>();
        return delay_imports_;
    }

    // Get delay import directory location
    uint32_t delay_import_rva = data_directory_rva(directory_entry::DELAY_IMPORT);
    uint32_t delay_import_size = data_directory_size(directory_entry::DELAY_IMPORT);

    // Parse delay import directory
    try {
        auto parsed = delay_import_directory_parser::parse(
            data_,
            sections_,
            delay_import_rva,
            delay_import_size,
            is_64bit_,
            image_base_
        );
        delay_imports_ = std::make_shared<delay_import_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty delay import directory
        // (allows graceful handling of malformed delay imports)
        delay_imports_ = std::make_shared<delay_import_directory>();
    }

    return delay_imports_;
}

std::shared_ptr<bound_import_directory> pe_file::bound_imports() const {
    // Lazy parsing: only parse bound import directory on first access
    if (bound_imports_) {
        return bound_imports_;
    }

    // Check if bound import directory exists
    if (!has_data_directory(directory_entry::BOUND_IMPORT)) {
        // Return empty bound import directory
        bound_imports_ = std::make_shared<bound_import_directory>();
        return bound_imports_;
    }

    // Get bound import directory location
    uint32_t bound_import_rva = data_directory_rva(directory_entry::BOUND_IMPORT);
    uint32_t bound_import_size = data_directory_size(directory_entry::BOUND_IMPORT);

    // Parse bound import directory
    try {
        auto parsed = bound_import_directory_parser::parse(
            data_,
            sections_,
            bound_import_rva,
            bound_import_size
        );
        bound_imports_ = std::make_shared<bound_import_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty bound import directory
        // (allows graceful handling of malformed bound imports)
        bound_imports_ = std::make_shared<bound_import_directory>();
    }

    return bound_imports_;
}

std::shared_ptr<security_directory> pe_file::security() const {
    // Lazy parsing: only parse security directory on first access
    if (security_) {
        return security_;
    }

    // Check if security directory exists
    if (!has_data_directory(directory_entry::SECURITY)) {
        // Return empty security directory
        security_ = std::make_shared<security_directory>();
        return security_;
    }

    // IMPORTANT: Unlike other data directories, the "RVA" field for security
    // directory is actually a FILE OFFSET, not an RVA!
    uint32_t security_offset = data_directory_rva(directory_entry::SECURITY);
    uint32_t security_size = data_directory_size(directory_entry::SECURITY);

    // Parse security directory
    try {
        auto parsed = security_directory_parser::parse(
            data_,
            security_offset,  // This is a file offset, not an RVA!
            security_size
        );
        security_ = std::make_shared<security_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty security directory
        // (allows graceful handling of malformed certificates)
        security_ = std::make_shared<security_directory>();
    }

    return security_;
}

std::shared_ptr<com_descriptor> pe_file::clr_header() const {
    // Lazy parsing: only parse COM descriptor on first access
    if (com_descriptor_) {
        return com_descriptor_;
    }

    // Check if COM descriptor exists
    if (!has_data_directory(directory_entry::COM_DESCRIPTOR)) {
        // Return empty COM descriptor (non-.NET executable)
        com_descriptor_ = std::make_shared<com_descriptor>();
        return com_descriptor_;
    }

    // Get COM descriptor location
    uint32_t com_descriptor_rva = data_directory_rva(directory_entry::COM_DESCRIPTOR);
    uint32_t com_descriptor_size = data_directory_size(directory_entry::COM_DESCRIPTOR);

    // Parse COM descriptor
    try {
        auto parsed = com_descriptor_parser::parse(
            data_,
            sections_,
            com_descriptor_rva,
            com_descriptor_size
        );
        com_descriptor_ = std::make_shared<com_descriptor>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty COM descriptor
        // (allows graceful handling of malformed .NET metadata)
        com_descriptor_ = std::make_shared<com_descriptor>();
    }

    return com_descriptor_;
}

std::shared_ptr<iat_directory> pe_file::import_address_table() const {
    // Lazy parsing: only parse IAT on first access
    if (iat_) {
        return iat_;
    }

    // Check if IAT exists
    if (!has_data_directory(directory_entry::IAT)) {
        // Return empty IAT (no data directory)
        iat_ = std::make_shared<iat_directory>();
        return iat_;
    }

    // Get IAT location
    uint32_t iat_rva = data_directory_rva(directory_entry::IAT);
    uint32_t iat_size = data_directory_size(directory_entry::IAT);

    // Parse IAT
    try {
        auto parsed = iat_directory_parser::parse(
            data_,
            sections_,
            iat_rva,
            iat_size,
            is_64bit_
        );
        iat_ = std::make_shared<iat_directory>(std::move(parsed));
    } catch (const std::exception& e) {
        // If parsing fails, return empty IAT
        iat_ = std::make_shared<iat_directory>();
    }

    return iat_;
}

std::shared_ptr<global_ptr_directory> pe_file::global_ptr() const {
    // Lazy parsing: only parse global pointer on first access
    if (global_ptr_) {
        return global_ptr_;
    }

    // Check if global pointer exists
    if (!has_data_directory(directory_entry::GLOBALPTR)) {
        // Return empty global pointer (no data directory)
        global_ptr_ = std::make_shared<global_ptr_directory>();
        return global_ptr_;
    }

    // Get global pointer value from data directory
    // Note: Unlike other directories, the RVA field itself IS the global pointer value
    uint32_t global_ptr_rva = data_directory_rva(directory_entry::GLOBALPTR);
    uint32_t global_ptr_size = data_directory_size(directory_entry::GLOBALPTR);

    // Parse global pointer (simple - just extract RVA)
    auto parsed = global_ptr_directory_parser::parse(global_ptr_rva, global_ptr_size);
    global_ptr_ = std::make_shared<global_ptr_directory>(std::move(parsed));

    return global_ptr_;
}

std::shared_ptr<architecture_directory> pe_file::architecture() const {
    // Lazy parsing: only parse architecture directory on first access
    if (architecture_) {
        return architecture_;
    }

    // Get architecture directory values from data directory
    // Note: According to PE/COFF spec, both RVA and size should be zero (reserved)
    uint32_t arch_rva = data_directory_rva(directory_entry::ARCHITECTURE);
    uint32_t arch_size = data_directory_size(directory_entry::ARCHITECTURE);

    // Parse architecture directory (simple - just extract RVA and size for validation)
    auto parsed = architecture_directory_parser::parse(arch_rva, arch_size);
    architecture_ = std::make_shared<architecture_directory>(std::move(parsed));

    return architecture_;
}

std::shared_ptr<reserved_directory> pe_file::reserved() const {
    // Lazy parsing: only parse reserved directory on first access
    if (reserved_) {
        return reserved_;
    }

    // Get reserved directory values from data directory
    // Note: According to PE/COFF spec, both RVA and size must be zero (reserved)
    uint32_t reserved_rva = data_directory_rva(directory_entry::RESERVED);
    uint32_t reserved_size = data_directory_size(directory_entry::RESERVED);

    // Parse reserved directory (simple - just extract RVA and size for validation)
    auto parsed = reserved_directory_parser::parse(reserved_rva, reserved_size);
    reserved_ = std::make_shared<reserved_directory>(std::move(parsed));

    return reserved_;
}

} // namespace libexe
