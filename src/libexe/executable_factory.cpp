// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/executable_factory.hpp>
#include <libexe/formats/mz_file.hpp>
#include <libexe/formats/ne_file.hpp>
#include <libexe/formats/pe_file.hpp>
#include <libexe/formats/le_file.hpp>
#include <libexe/core/data_source.hpp>
#include <formats/mz/mz.hh>  // Generated by DataScript (modular)
#include <formats/pe/pe_header/pe_header.hh>  // Generated by DataScript (modular)
#include <stdexcept>
#include <cstring>

namespace libexe {

format_type executable_factory::detect_format(std::span<const uint8_t> data) {
    if (data.size() < 2) {
        throw std::runtime_error("File too small to be a valid executable");
    }

    const uint8_t* ptr = data.data();
    const uint8_t* end = ptr + data.size();

    // Check for raw LE/LX (no MZ stub)
    uint16_t first_sig = formats::pe::pe_header::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind

    if (first_sig == 0x454C) {  // 'LE' - Raw LE
        return format_type::LE_DOS32_RAW;
    }
    if (first_sig == 0x584C) {  // 'LX' - Raw LX
        return format_type::LX_OS2_RAW;
    }

    // Check MZ signature
    if (first_sig != 0x5A4D) {
        return format_type::UNKNOWN;
    }

    if (data.size() < 64) {  // Minimum for DOS header
        throw std::runtime_error("File too small to be a valid DOS executable");
    }

    // Parse DOS header to get e_lfanew
    try {
        auto dos_header = formats::mz::image_dos_header::read(ptr, end);
        uint32_t new_exe_offset = dos_header.e_lfanew;

        // Check if there's an extended header
        if (new_exe_offset == 0 || new_exe_offset >= data.size() - 4) {
            return format_type::MZ_DOS;  // Plain DOS executable
        }

        // Read signature at e_lfanew
        ptr = data.data() + new_exe_offset;
        uint16_t ext_sig = formats::pe::pe_header::read_uint16_le(ptr, end);
        ptr -= 2;  // Rewind

        // Check for NE signature (0x454E = 'NE')
        if (ext_sig == 0x454E) {
            return format_type::NE_WIN16;
        }

        // Check for LE signature (0x454C = 'LE') - bound to DOS extender
        if (ext_sig == 0x454C) {
            // Check OS type to distinguish VxD from DOS32
            // OS type is at offset 0x0A in LE header
            if (new_exe_offset + 0x0C <= data.size()) {
                uint16_t os_type = static_cast<uint16_t>(data[new_exe_offset + 0x0A]) |
                                   (static_cast<uint16_t>(data[new_exe_offset + 0x0B]) << 8);
                if (os_type == 0x02) {  // Windows (VxD)
                    return format_type::LE_VXD;
                }
            }
            return format_type::LE_DOS32_BOUND;
        }

        // Check for LX signature (0x584C = 'LX') - bound OS/2 executable
        if (ext_sig == 0x584C) {
            return format_type::LX_OS2_BOUND;
        }

        // Check for PE signature (0x4550 = 'PE\0\0')
        uint32_t pe_sig = formats::pe::pe_header::read_uint32_le(ptr, end);
        if (pe_sig == 0x00004550) {
            // Determine PE32 vs PE32+ by reading optional header magic
            // Skip COFF header (20 bytes after PE signature)
            ptr += 20;
            if (ptr + 2 <= end) {
                uint16_t magic = formats::pe::pe_header::read_uint16_le(ptr, end);
                if (magic == 0x010B) {
                    return format_type::PE_WIN32;
                } else if (magic == 0x020B) {
                    return format_type::PE_PLUS_WIN64;
                }
            }
            // If we can't read the magic, assume PE32
            return format_type::PE_WIN32;
        }

        // Unknown extended format
        return format_type::MZ_DOS;  // Treat as plain DOS

    } catch (const std::exception&) {
        // If parsing fails, treat as unknown
        return format_type::UNKNOWN;
    }
}

format_type executable_factory::detect_format(const std::filesystem::path& path) {
    // Use mmap for format detection to avoid reading whole file
    mmap_data_source mmap_data(path);
    return detect_format(mmap_data.span());
}

format_type executable_factory::detect_format(const data_source& source) {
    return detect_format(source.span());
}

executable_variant executable_factory::from_memory(std::span<const uint8_t> data) {
    format_type type = detect_format(data);

    switch (type) {
        case format_type::MZ_DOS:
            return mz_file::from_memory(data);

        case format_type::NE_WIN16:
            return ne_file::from_memory(data);

        case format_type::PE_WIN32:
        case format_type::PE_PLUS_WIN64:
            return pe_file::from_memory(data);

        case format_type::LE_DOS32_BOUND:
        case format_type::LE_DOS32_RAW:
        case format_type::LE_VXD:
        case format_type::LX_OS2_BOUND:
        case format_type::LX_OS2_RAW:
            return le_file::from_memory(data);

        case format_type::UNKNOWN:
        default:
            throw std::runtime_error("Unknown or unsupported executable format");
    }
}

executable_variant executable_factory::from_file(const std::filesystem::path& path) {
    // Use mmap for format detection, then call format-specific from_file
    // which will also use mmap internally
    format_type type = detect_format(path);

    switch (type) {
        case format_type::MZ_DOS:
            return mz_file::from_file(path);

        case format_type::NE_WIN16:
            return ne_file::from_file(path);

        case format_type::PE_WIN32:
        case format_type::PE_PLUS_WIN64:
            return pe_file::from_file(path);

        case format_type::LE_DOS32_BOUND:
        case format_type::LE_DOS32_RAW:
        case format_type::LE_VXD:
        case format_type::LX_OS2_BOUND:
        case format_type::LX_OS2_RAW:
            return le_file::from_file(path);

        case format_type::UNKNOWN:
        default:
            throw std::runtime_error("Unknown or unsupported executable format");
    }
}

executable_variant executable_factory::from_data_source(std::unique_ptr<data_source> source) {
    if (!source) {
        throw std::runtime_error("Null data source provided");
    }

    format_type type = detect_format(*source);

    switch (type) {
        case format_type::MZ_DOS:
            return mz_file::from_data_source(std::move(source));

        case format_type::NE_WIN16:
            return ne_file::from_data_source(std::move(source));

        case format_type::PE_WIN32:
        case format_type::PE_PLUS_WIN64:
            return pe_file::from_data_source(std::move(source));

        case format_type::LE_DOS32_BOUND:
        case format_type::LE_DOS32_RAW:
        case format_type::LE_VXD:
        case format_type::LX_OS2_BOUND:
        case format_type::LX_OS2_RAW:
            return le_file::from_data_source(std::move(source));

        case format_type::UNKNOWN:
        default:
            throw std::runtime_error("Unknown or unsupported executable format");
    }
}

std::string_view executable_factory::format_type_name(format_type type) {
    switch (type) {
        case format_type::MZ_DOS:
            return "MZ (DOS)";
        case format_type::NE_WIN16:
            return "NE (16-bit Windows/OS2)";
        case format_type::PE_WIN32:
            return "PE32 (32-bit Windows)";
        case format_type::PE_PLUS_WIN64:
            return "PE32+ (64-bit Windows)";
        case format_type::LE_DOS32_BOUND:
            return "LE (32-bit DOS with extender)";
        case format_type::LE_DOS32_RAW:
            return "LE (32-bit DOS raw)";
        case format_type::LE_VXD:
            return "LE (Windows VxD)";
        case format_type::LX_OS2_BOUND:
            return "LX (OS/2 with stub)";
        case format_type::LX_OS2_RAW:
            return "LX (OS/2 raw)";
        case format_type::UNKNOWN:
        default:
            return "Unknown";
    }
}

} // namespace libexe
