// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/executable_factory.hpp>
#include <libexe/mz_file.hpp>
#include <libexe/ne_file.hpp>
#include <libexe/pe_file.hpp>
#include "exe_format.hh"  // Generated by DataScript from formats/exe_format_complete.ds
#include <fstream>
#include <stdexcept>
#include <cstring>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

format_type executable_factory::detect_format(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS header
        throw std::runtime_error("File too small to be a valid executable");
    }

    const uint8_t* ptr = data.data();
    const uint8_t* end = ptr + data.size();

    // Check MZ signature
    uint16_t mz_sig = formats::exe_format_complete::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind for full parse

    if (mz_sig != formats::exe_format_complete::DOS_SIGNATURE) {
        return format_type::UNKNOWN;
    }

    // Parse DOS header to get e_lfanew
    try {
        auto dos_header = formats::exe_format_complete::ImageDosHeader::read(ptr, end);
        uint32_t new_exe_offset = dos_header.e_lfanew;

        // Check if there's an extended header
        if (new_exe_offset == 0 || new_exe_offset >= data.size() - 4) {
            return format_type::MZ_DOS;  // Plain DOS executable
        }

        // Read signature at e_lfanew
        ptr = data.data() + new_exe_offset;
        uint16_t ext_sig = formats::exe_format_complete::read_uint16_le(ptr, end);
        ptr -= 2;  // Rewind

        // Check for NE signature (0x4E45 = 'NE')
        if (ext_sig == formats::exe_format_complete::NE_SIGNATURE) {
            return format_type::NE_WIN16;
        }

        // Check for PE signature (0x4550 = 'PE\0\0')
        uint32_t pe_sig = formats::exe_format_complete::read_uint32_le(ptr, end);
        if (pe_sig == formats::exe_format_complete::PE_SIGNATURE) {
            // Determine PE32 vs PE32+ by reading optional header magic
            // Skip COFF header (20 bytes after PE signature)
            ptr += 20;
            if (ptr + 2 <= end) {
                uint16_t magic = formats::exe_format_complete::read_uint16_le(ptr, end);
                if (magic == formats::exe_format_complete::PE32_MAGIC) {
                    return format_type::PE_WIN32;
                } else if (magic == formats::exe_format_complete::PE32PLUS_MAGIC) {
                    return format_type::PE_PLUS_WIN64;
                }
            }
            // If we can't read the magic, assume PE32
            return format_type::PE_WIN32;
        }

        // Unknown extended format
        return format_type::MZ_DOS;  // Treat as plain DOS

    } catch (const std::exception&) {
        // If parsing fails, treat as unknown
        return format_type::UNKNOWN;
    }
}

format_type executable_factory::detect_format(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return detect_format(data);
}

executable_variant executable_factory::load(std::span<const uint8_t> data) {
    format_type type = detect_format(data);

    switch (type) {
        case format_type::MZ_DOS:
            return mz_file::from_memory(data);

        case format_type::NE_WIN16:
            return ne_file::from_memory(data);

        case format_type::PE_WIN32:
        case format_type::PE_PLUS_WIN64:
            return pe_file::from_memory(data);

        case format_type::UNKNOWN:
        default:
            throw std::runtime_error("Unknown or unsupported executable format");
    }
}

executable_variant executable_factory::load(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return load(data);
}

std::string_view executable_factory::format_type_name(format_type type) {
    switch (type) {
        case format_type::MZ_DOS:
            return "MZ (DOS)";
        case format_type::NE_WIN16:
            return "NE (16-bit Windows/OS2)";
        case format_type::PE_WIN32:
            return "PE32 (32-bit Windows)";
        case format_type::PE_PLUS_WIN64:
            return "PE32+ (64-bit Windows)";
        case format_type::UNKNOWN:
        default:
            return "Unknown";
    }
}

} // namespace libexe
