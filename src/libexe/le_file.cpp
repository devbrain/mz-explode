// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/le_file.hpp>
#include <libexe/core/entropy.hpp>
#include "core/utils.hpp"
#include <libexe/core/data_source.hpp>
#include <formats/mz/mz.hh>   // Generated by DataScript (modular)
#include <formats/le/le_header/le_header.hh>  // Generated by DataScript (modular)
#include <stdexcept>
#include <cstring>
#include <algorithm>

namespace libexe {

// Special member functions
le_file::le_file() = default;
le_file::~le_file() = default;
le_file::le_file(le_file&&) noexcept = default;
le_file& le_file::operator=(le_file&&) noexcept = default;

// =============================================================================
// LX Page Decompression
// Based on public domain code by Alexander Taylor / Veit Kannegieser / Max Alekseyev
// from os2-gpi-font-tools project
// =============================================================================

// EXEPACK1 decompression (iterated pages - simple run-length encoding)
// Returns decompressed size, output written to out_buffer (must be at least 4096 bytes)
static size_t lx_unpack1(const uint8_t* input, size_t input_size, uint8_t* output) {
    if (input_size > 4096) {
        // Not compressed, just copy
        std::memcpy(output, input, input_size);
        return input_size;
    }

    size_t in_pos = 0;
    size_t out_pos = 0;

    while (in_pos + 4 <= input_size) {
        // Read repetition count (little-endian 16-bit)
        uint16_t reps = static_cast<uint16_t>(input[in_pos]) |
                       (static_cast<uint16_t>(input[in_pos + 1]) << 8);
        if (reps == 0) break;
        in_pos += 2;

        // Read sequence length (little-endian 16-bit)
        uint16_t len = static_cast<uint16_t>(input[in_pos]) |
                      (static_cast<uint16_t>(input[in_pos + 1]) << 8);
        in_pos += 2;

        // Check bounds
        if (out_pos + (reps * len) > 4096) break;
        if (in_pos + len > input_size) break;

        // Copy sequence 'reps' times
        for (uint16_t r = 0; r < reps; ++r) {
            std::memcpy(output + out_pos, input + in_pos, len);
            out_pos += len;
        }
        in_pos += len;
    }

    return out_pos;
}

// Helper for EXEPACK2: byte-by-byte copy that handles overlapping regions
static void copy_byte_seq(uint8_t* target, const uint8_t* source, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        target[i] = source[i];
    }
}

// EXEPACK2 decompression (modified Lempel-Ziv)
// Returns decompressed size, output written to out_buffer (must be at least 4096 bytes)
static size_t lx_unpack2(const uint8_t* input, size_t input_size, uint8_t* output) {
    if (input_size > 4096) {
        std::memcpy(output, input, input_size);
        return input_size;
    }

    std::memset(output, 0, 4096);
    size_t in_pos = 0;
    size_t out_pos = 0;

    while (in_pos + 2 <= input_size) {
        // Read control word (little-endian 16-bit)
        uint16_t control = static_cast<uint16_t>(input[in_pos]) |
                          (static_cast<uint16_t>(input[in_pos + 1]) << 8);

        // Bits 1 & 0 hold the case flag (0-3)
        switch (control & 0x3) {
            case 0: {
                if ((control & 0xFF) == 0) {
                    // When length1 == 0, fill (length2) bytes with the byte value following control
                    uint32_t len = (control >> 8) & 0xFF;
                    if (len == 0) goto done;
                    if (in_pos + 2 >= input_size) goto done;
                    std::memset(output + out_pos, input[in_pos + 2], len);
                    in_pos += 3;
                    out_pos += len;
                } else {
                    // Block copy (length1) bytes from after control word
                    uint32_t len = (control >> 2) & 0x3F;
                    if (in_pos + 1 + len > input_size) goto done;
                    if (out_pos + len > 4096) goto done;  // Buffer overflow check
                    std::memcpy(output + out_pos, input + in_pos + 1, len);
                    in_pos += len + 1;
                    out_pos += len;
                }
                break;
            }

            case 1: {
                // bits 15..7  = backwards reference
                // bits  6..4  +3 = length2
                // bits  3..2  = length1
                uint32_t len1 = (control >> 2) & 0x3;
                if (in_pos + 2 + len1 > input_size) goto done;
                if (out_pos + len1 > 4096) goto done;  // Buffer overflow check
                std::memcpy(output + out_pos, input + in_pos + 2, len1);
                in_pos += len1 + 2;
                out_pos += len1;

                uint32_t len2 = ((control >> 4) & 0x7) + 3;
                uint32_t back_ref = (control >> 7) & 0x1FF;
                if (back_ref > out_pos) goto done;
                if (out_pos + len2 > 4096) goto done;  // Buffer overflow check
                copy_byte_seq(output + out_pos, output + out_pos - back_ref, len2);
                out_pos += len2;
                break;
            }

            case 2: {
                // bits 15.. 4 = backwards reference
                // bits  3.. 2 +3 = length
                uint32_t len = ((control >> 2) & 0x3) + 3;
                uint32_t back_ref = (control >> 4) & 0xFFF;
                if (back_ref > out_pos) goto done;
                if (out_pos + len > 4096) goto done;  // Buffer overflow check
                copy_byte_seq(output + out_pos, output + out_pos - back_ref, len);
                in_pos += 2;
                out_pos += len;
                break;
            }

            case 3: {
                // Need 4-byte control word
                if (in_pos + 4 > input_size) goto done;
                uint32_t control32 = static_cast<uint32_t>(input[in_pos]) |
                                    (static_cast<uint32_t>(input[in_pos + 1]) << 8) |
                                    (static_cast<uint32_t>(input[in_pos + 2]) << 16) |
                                    (static_cast<uint32_t>(input[in_pos + 3]) << 24);

                // bits 20..12 = backwards reference
                // bits 11.. 6 = length2
                // bits  5.. 2 = length1
                uint32_t len1 = (control32 >> 2) & 0xF;
                if (in_pos + 3 + len1 > input_size) goto done;
                if (out_pos + len1 > 4096) goto done;  // Buffer overflow check
                std::memcpy(output + out_pos, input + in_pos + 3, len1);
                in_pos += len1 + 3;
                out_pos += len1;

                uint32_t len2 = (control32 >> 6) & 0x3F;
                uint32_t back_ref = (control32 >> 12) & 0xFFF;
                if (back_ref > out_pos) goto done;
                if (out_pos + len2 > 4096) goto done;  // Buffer overflow check
                copy_byte_seq(output + out_pos, output + out_pos - back_ref, len2);
                out_pos += len2;
                break;
            }
        }

        if (out_pos >= 4096) break;
    }

done:
    return 4096;  // EXEPACK2 always produces 4096 bytes (except for last page)
}

// =============================================================================

// Factory methods
le_file le_file::from_file(const std::filesystem::path& path) {
    le_file file;
    file.data_ = std::make_unique<mmap_data_source>(path);

    try {
        file.parse_le_headers();
        file.parse_objects();
        file.parse_page_table();
        file.parse_entry_table();
        file.parse_import_module_table();
        file.parse_fixup_tables();
        file.parse_resource_table();
    } catch (const formats::le::le_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid LE/LX file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing LE/LX file: ") + e.what());
    }

    return file;
}

le_file le_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 2) {
        throw std::runtime_error("File too small to be a valid LE/LX executable");
    }

    le_file file;
    file.data_ = std::make_unique<vector_data_source>(data);

    try {
        file.parse_le_headers();
        file.parse_objects();
        file.parse_page_table();
        file.parse_entry_table();
        file.parse_import_module_table();
        file.parse_fixup_tables();
        file.parse_resource_table();
    } catch (const formats::le::le_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid LE/LX file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing LE/LX file: ") + e.what());
    }

    return file;
}

le_file le_file::from_data_source(std::unique_ptr<data_source> source) {
    if (!source || source->size() < 2) {
        throw std::runtime_error("File too small to be a valid LE/LX executable");
    }

    le_file file;
    file.data_ = std::move(source);

    try {
        file.parse_le_headers();
        file.parse_objects();
        file.parse_page_table();
        file.parse_entry_table();
        file.parse_import_module_table();
        file.parse_fixup_tables();
        file.parse_resource_table();
    } catch (const formats::le::le_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid LE/LX file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing LE/LX file: ") + e.what());
    }

    return file;
}

void le_file::parse_le_headers() {
    const uint8_t* ptr = data_->data();
    const uint8_t* end = ptr + data_->size();

    // Check for raw LE/LX (starts with 'LE' or 'LX')
    uint16_t first_sig = formats::le::le_header::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind

    if (first_sig == 0x454C || first_sig == 0x584C) {
        // Raw LE/LX - no MZ stub
        is_bound_ = false;
        le_header_offset_ = 0;
        extender_type_ = dos_extender_type::NONE;
    } else if (first_sig == 0x5A4D) {
        // MZ header present - parse DOS header to get LE offset
        auto dos_header = formats::mz::image_dos_header::read(ptr, end);
        le_header_offset_ = dos_header.e_lfanew;

        // Validate e_lfanew and check if it points to LE/LX
        bool valid_lfanew = (le_header_offset_ != 0 &&
                            le_header_offset_ < data_->size() - 4);

        if (valid_lfanew) {
            // Check if e_lfanew actually points to LE/LX signature
            uint16_t sig_at_lfanew = static_cast<uint16_t>((*data_)[le_header_offset_]) |
                                    (static_cast<uint16_t>((*data_)[le_header_offset_ + 1]) << 8);
            if (sig_at_lfanew != 0x454C && sig_at_lfanew != 0x584C) {
                valid_lfanew = false;
            }
        }

        if (!valid_lfanew) {
            // e_lfanew is invalid or doesn't point to LE/LX
            // DOS/4GW bound executables often have garbage in e_lfanew
            // Search for LE/LX signature in the file
            le_header_offset_ = 0;
            for (size_t i = 0x40; i < data_->size() - 4; i++) {
                uint16_t sig = static_cast<uint16_t>((*data_)[i]) |
                              (static_cast<uint16_t>((*data_)[i + 1]) << 8);
                // Check for 'LE' or 'LX' followed by 00 00 (byte/word order)
                if ((sig == 0x454C || sig == 0x584C) &&
                    (*data_)[i + 2] == 0x00 && (*data_)[i + 3] == 0x00) {
                    le_header_offset_ = static_cast<uint32_t>(i);
                    break;
                }
            }

            if (le_header_offset_ == 0) {
                throw std::runtime_error("Cannot find LE/LX header in bound executable");
            }
        }

        is_bound_ = true;
        detect_extender_type();
    } else {
        throw std::runtime_error("Not a valid LE/LX file (invalid signature)");
    }

    // Parse LE/LX header
    ptr = data_->data() + le_header_offset_;
    auto le_header = formats::le::le_header::image_le_header::read(ptr, end);

    // Validate signature
    uint16_t sig = le_header.le_magic;
    if (sig == 0x454C) {
        is_lx_ = false;
    } else if (sig == 0x584C) {
        is_lx_ = true;
    } else {
        throw std::runtime_error("Invalid LE/LX signature");
    }

    // Extract header fields
    cpu_type_ = static_cast<uint16_t>(le_header.cpu_type);
    os_type_ = static_cast<uint16_t>(le_header.os_type);
    module_version_ = le_header.module_version;
    module_flags_ = static_cast<uint32_t>(le_header.module_flags);
    page_count_ = le_header.page_count;
    page_size_ = le_header.page_size;
    page_offset_shift_ = le_header.page_offset_shift;

    // Entry point
    eip_object_ = le_header.eip_object;
    eip_ = le_header.eip;
    esp_object_ = le_header.esp_object;
    esp_ = le_header.esp;

    // Table offsets (relative to LE header)
    object_table_offset_ = le_header.object_table_offset;
    object_count_ = le_header.object_count;
    page_table_offset_ = le_header.object_page_table_offset;
    resource_table_offset_ = le_header.resource_table_offset;
    resource_count_ = le_header.resource_count;
    resident_name_table_offset_ = le_header.resident_name_table_offset;
    entry_table_offset_ = le_header.entry_table_offset;
    import_module_table_offset_ = le_header.import_module_table_offset;
    import_module_count_ = le_header.import_module_count;
    import_proc_table_offset_ = le_header.import_proc_table_offset;
    fixup_page_table_offset_ = le_header.fixup_page_table_offset;
    fixup_record_table_offset_ = le_header.fixup_record_table_offset;

    // Absolute file offsets
    data_pages_offset_ = le_header.data_pages_offset;
    nonresident_name_table_offset_ = le_header.nonresident_name_table_offset;
    nonresident_name_table_size_ = le_header.nonresident_name_table_size;
    debug_info_offset_ = le_header.debug_info_offset;
    debug_info_size_ = le_header.debug_info_size;

    // Additional header fields
    preload_page_count_ = le_header.preload_page_count;
    heap_size_ = le_header.heap_size;
    stack_size_ = le_header.stack_size;
    auto_data_object_ = le_header.auto_data_object;
    instance_preload_ = le_header.instance_preload;
    instance_demand_ = le_header.instance_demand;
}

void le_file::detect_extender_type() {
    // Try to detect DOS extender type from the MZ stub
    // Common signatures at specific offsets

    // DOS/32A signatures
    if (data_->size() > 0x80) {
        // Check for "DOS/32A" string
        auto find_signature = [this](const char* sig, size_t sig_len) {
            auto it = std::search(data_->begin(), data_->end(),
                                  sig, sig + sig_len);
            return it != data_->end();
        };

        if (find_signature("DOS/32A", 7)) {
            extender_type_ = dos_extender_type::DOS32A;
            return;
        }
        if (find_signature("STUB/32A", 8)) {
            extender_type_ = dos_extender_type::STUB32A;
            return;
        }
        if (find_signature("STUB/32C", 8)) {
            extender_type_ = dos_extender_type::STUB32C;
            return;
        }
        if (find_signature("DOS/4G", 6)) {
            extender_type_ = dos_extender_type::DOS4G;
            return;
        }
        if (find_signature("DOS4GW", 6) || find_signature("DOS/4GW", 7)) {
            extender_type_ = dos_extender_type::DOS4GW;
            return;
        }
        if (find_signature("PMODE/W", 7)) {
            extender_type_ = dos_extender_type::PMODEW;
            return;
        }
        if (find_signature("CauseWay", 8)) {
            extender_type_ = dos_extender_type::CAUSEWAY;
            return;
        }
        if (find_signature("WDOSX", 5)) {
            extender_type_ = dos_extender_type::WDOSX;
            return;
        }
        if (find_signature("CWSDPMI", 7)) {
            extender_type_ = dos_extender_type::CWSDPMI;
            return;
        }
    }

    extender_type_ = dos_extender_type::UNKNOWN;
}

void le_file::parse_objects() {
    if (object_count_ == 0) {
        return;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + object_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    objects_.reserve(object_count_);

    for (uint32_t i = 0; i < object_count_; ++i) {
        if (ptr + 24 > end) {
            diagnostics_.warning(diagnostic_code::LE_INVALID_OBJECT_INDEX,
                                "Object table truncated");
            break;
        }

        auto entry = formats::le::le_header::le_object_table_entry::read(ptr, end);

        le_object obj;
        obj.index = i + 1;  // 1-based
        obj.virtual_size = entry.virtual_size;
        obj.base_address = entry.base_address;
        obj.flags = static_cast<uint32_t>(entry.flags);
        obj.page_table_index = entry.page_table_index;
        obj.page_count = entry.page_count;

        objects_.push_back(obj);
    }
}

void le_file::parse_page_table() {
    // Calculate total pages needed
    uint32_t total_pages = 0;
    for (const auto& obj : objects_) {
        total_pages += obj.page_count;
    }

    if (total_pages == 0) {
        return;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + page_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    page_table_.reserve(total_pages);

    for (uint32_t i = 0; i < total_pages; ++i) {
        le_page_entry page;
        page.page_number = i + 1;

        if (is_lx_) {
            // LX format: 8-byte page entries
            if (ptr + 8 > end) {
                diagnostics_.warning(diagnostic_code::LE_INVALID_PAGE_OFFSET,
                                    "Page table truncated");
                break;
            }

            auto entry = formats::le::le_header::lx_page_table_entry::read(ptr, end);
            // LX: offset is shifted by page_offset_shift
            page.file_offset = data_pages_offset_ +
                              (entry.offset << page_offset_shift_);
            page.data_size = entry.data_size;
            page.flags = static_cast<uint16_t>(entry.flags);
        } else {
            // LE format: 4-byte page entries
            if (ptr + 4 > end) {
                diagnostics_.warning(diagnostic_code::LE_INVALID_PAGE_OFFSET,
                                    "Page table truncated");
                break;
            }

            auto entry = formats::le::le_header::le_page_table_entry::read(ptr, end);
            // LE: 24-bit offset stored as high/med/low bytes
            uint32_t page_num = (static_cast<uint32_t>(entry.high) << 16) |
                               (static_cast<uint32_t>(entry.med) << 8) |
                               static_cast<uint32_t>(entry.low);
            // LE: offset is (page_number - 1) * page_size from data_pages_offset
            if (page_num > 0) {
                page.file_offset = data_pages_offset_ + (page_num - 1) * page_size_;
            } else {
                page.file_offset = 0;
            }
            page.data_size = static_cast<uint16_t>(page_size_);
            page.flags = entry.flags;
        }

        page_table_.push_back(page);
    }
}

void le_file::parse_entry_table() {
    if (entry_table_offset_ == 0) {
        return;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + entry_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    uint16_t current_ordinal = 1;  // Ordinals are 1-based

    while (ptr < end) {
        // Read bundle header (2 bytes)
        if (ptr + 2 > end) {
            diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                "Entry table truncated at bundle header");
            break;
        }

        uint8_t count = *ptr++;
        uint8_t type = *ptr++;

        // count == 0 terminates the entry table
        if (count == 0) {
            break;
        }

        // type == 0 means skip (unused entries)
        if (type == 0) {
            current_ordinal += count;
            continue;
        }

        // Read object number for this bundle
        uint16_t object_num = 0;
        if (type == 0x01 || type == 0x02) {
            // 16-bit and 286 gate: 1-byte object number
            if (ptr + 1 > end) {
                diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                    "Entry table truncated at object number");
                break;
            }
            object_num = *ptr++;
        } else if (type == 0x03) {
            // 32-bit: 2-byte object number
            if (ptr + 2 > end) {
                diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                    "Entry table truncated at object number");
                break;
            }
            object_num = static_cast<uint16_t>(ptr[0]) |
                        (static_cast<uint16_t>(ptr[1]) << 8);
            ptr += 2;
        } else if (type == 0x04) {
            // Forwarder: 2-byte reserved (must be 0)
            if (ptr + 2 > end) {
                diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                    "Entry table truncated at forwarder reserved");
                break;
            }
            ptr += 2;  // Skip reserved bytes
        }

        // Parse entries in bundle
        for (uint8_t i = 0; i < count; ++i) {
            le_entry entry{};
            entry.ordinal = current_ordinal++;
            entry.type = static_cast<le_entry_type>(type);
            entry.object = object_num;
            entry.callgate = 0;
            entry.module_ordinal = 0;
            entry.import_ordinal = 0;

            switch (type) {
                case 0x01: {  // 16-bit entry (3 bytes)
                    if (ptr + 3 > end) {
                        diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                            "Entry table truncated at 16-bit entry");
                        return;
                    }
                    entry.flags = *ptr++;
                    entry.offset = static_cast<uint32_t>(ptr[0]) |
                                  (static_cast<uint32_t>(ptr[1]) << 8);
                    ptr += 2;
                    break;
                }

                case 0x02: {  // 286 call gate (5 bytes)
                    if (ptr + 5 > end) {
                        diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                            "Entry table truncated at 286 gate entry");
                        return;
                    }
                    entry.flags = *ptr++;
                    entry.offset = static_cast<uint32_t>(ptr[0]) |
                                  (static_cast<uint32_t>(ptr[1]) << 8);
                    ptr += 2;
                    entry.callgate = static_cast<uint16_t>(ptr[0]) |
                                    (static_cast<uint16_t>(ptr[1]) << 8);
                    ptr += 2;
                    break;
                }

                case 0x03: {  // 32-bit entry (5 bytes)
                    if (ptr + 5 > end) {
                        diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                            "Entry table truncated at 32-bit entry");
                        return;
                    }
                    entry.flags = *ptr++;
                    entry.offset = static_cast<uint32_t>(ptr[0]) |
                                  (static_cast<uint32_t>(ptr[1]) << 8) |
                                  (static_cast<uint32_t>(ptr[2]) << 16) |
                                  (static_cast<uint32_t>(ptr[3]) << 24);
                    ptr += 4;
                    break;
                }

                case 0x04: {  // Forwarder entry (7 bytes)
                    if (ptr + 7 > end) {
                        diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                            "Entry table truncated at forwarder entry");
                        return;
                    }
                    entry.flags = *ptr++;
                    entry.module_ordinal = static_cast<uint16_t>(ptr[0]) |
                                          (static_cast<uint16_t>(ptr[1]) << 8);
                    ptr += 2;
                    entry.import_ordinal = static_cast<uint32_t>(ptr[0]) |
                                          (static_cast<uint32_t>(ptr[1]) << 8) |
                                          (static_cast<uint32_t>(ptr[2]) << 16) |
                                          (static_cast<uint32_t>(ptr[3]) << 24);
                    ptr += 4;
                    break;
                }

                default:
                    diagnostics_.warning(diagnostic_code::LE_ENTRY_INVALID,
                                        "Unknown entry bundle type");
                    return;
            }

            entries_.push_back(entry);
        }
    }
}

void le_file::parse_import_module_table() {
    if (import_module_table_offset_ == 0 || import_module_count_ == 0) {
        return;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + import_module_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    import_modules_.reserve(import_module_count_);

    for (uint32_t i = 0; i < import_module_count_; ++i) {
        if (ptr >= end) {
            diagnostics_.warning(diagnostic_code::LE_IMPORT_UNRESOLVED,
                                "Import module table truncated");
            break;
        }

        uint8_t len = *ptr++;
        if (len == 0) {
            // Empty name - add empty string
            import_modules_.emplace_back("");
            continue;
        }

        if (ptr + len > end) {
            diagnostics_.warning(diagnostic_code::LE_IMPORT_UNRESOLVED,
                                "Import module name truncated");
            break;
        }

        import_modules_.emplace_back(reinterpret_cast<const char*>(ptr), len);
        ptr += len;
    }
}

void le_file::parse_fixup_tables() {
    // Fixup parsing is complex. The structure is:
    // 1. Fixup Page Table: array of uint32_t offsets into fixup record table
    //    - One entry per page + 1 (to calculate size of last page's fixups)
    // 2. Fixup Record Table: variable-length fixup records

    if (fixup_page_table_offset_ == 0 || fixup_record_table_offset_ == 0) {
        return;
    }

    if (page_count_ == 0) {
        return;
    }

    const uint8_t* base = data_->data() + le_header_offset_;
    const uint8_t* end = data_->data() + data_->size();

    // Read fixup page table (one uint32_t per page + 1)
    const uint8_t* page_table_ptr = base + fixup_page_table_offset_;
    const uint8_t* record_table_ptr = base + fixup_record_table_offset_;

    if (page_table_ptr + (page_count_ + 1) * 4 > end) {
        diagnostics_.warning(diagnostic_code::LE_FIXUP_OVERFLOW,
                            "Fixup page table extends beyond file");
        return;
    }

    // Helper to read little-endian values
    auto read_u16 = [](const uint8_t* p) -> uint16_t {
        return static_cast<uint16_t>(p[0]) | (static_cast<uint16_t>(p[1]) << 8);
    };
    auto read_u32 = [](const uint8_t* p) -> uint32_t {
        return static_cast<uint32_t>(p[0]) |
               (static_cast<uint32_t>(p[1]) << 8) |
               (static_cast<uint32_t>(p[2]) << 16) |
               (static_cast<uint32_t>(p[3]) << 24);
    };

    // Process each page's fixups
    for (uint32_t page = 0; page < page_count_; ++page) {
        uint32_t fixup_start = read_u32(page_table_ptr + page * 4);
        uint32_t fixup_end = read_u32(page_table_ptr + (page + 1) * 4);

        if (fixup_start >= fixup_end) {
            continue;  // No fixups for this page
        }

        const uint8_t* ptr = record_table_ptr + fixup_start;
        const uint8_t* page_fixup_end = record_table_ptr + fixup_end;

        if (page_fixup_end > end) {
            diagnostics_.warning(diagnostic_code::LE_FIXUP_OVERFLOW,
                                "Fixup records extend beyond file");
            break;
        }

        // Parse fixup records for this page
        while (ptr < page_fixup_end) {
            if (ptr + 2 > page_fixup_end) {
                break;
            }

            // Read fixup header (2 bytes)
            uint8_t source_byte = *ptr++;
            uint8_t target_byte = *ptr++;

            // Parse source flags
            uint8_t source_type = source_byte & 0x0F;
            bool is_alias = (source_byte & 0x10) != 0;
            bool source_list = (source_byte & 0x20) != 0;

            // Parse target flags
            uint8_t target_type = target_byte & 0x03;
            bool additive = (target_byte & 0x04) != 0;
            // bool chaining = (target_byte & 0x08) != 0;  // LX internal chaining
            bool target_32bit = (target_byte & 0x10) != 0;
            bool additive_32bit = (target_byte & 0x20) != 0;
            bool ordinal_16bit = (target_byte & 0x40) != 0;
            bool ordinal_8bit = (target_byte & 0x80) != 0;

            // Read source offset(s)
            uint8_t source_count = 1;
            std::vector<uint16_t> source_offsets;

            if (source_list) {
                if (ptr >= page_fixup_end) break;
                source_count = *ptr++;
            }

            for (uint8_t i = 0; i < source_count; ++i) {
                if (ptr + 2 > page_fixup_end) break;
                source_offsets.push_back(read_u16(ptr));
                ptr += 2;
            }

            if (source_offsets.empty()) {
                continue;
            }

            // Read target info based on target type
            le_fixup fixup{};
            fixup.page_index = page + 1;  // 1-based
            fixup.source_type = static_cast<le_fixup_source_type>(source_type);
            fixup.target_type = static_cast<le_fixup_target_type>(target_type);
            fixup.is_alias = is_alias;
            fixup.is_additive = additive;
            fixup.target_object = 0;
            fixup.target_offset = 0;
            fixup.module_ordinal = 0;
            fixup.import_ordinal = 0;
            fixup.additive_value = 0;

            switch (target_type) {
                case 0x00: {  // INTERNAL
                    // Object number
                    if (ordinal_16bit) {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.target_object = read_u16(ptr);
                        ptr += 2;
                    } else if (ordinal_8bit) {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.target_object = *ptr++;
                    } else {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.target_object = *ptr++;
                    }

                    // Target offset (if source type needs it)
                    if (source_type != 0x02) {  // Not selector-only
                        if (target_32bit) {
                            if (ptr + 4 > page_fixup_end) goto done_page;
                            fixup.target_offset = read_u32(ptr);
                            ptr += 4;
                        } else {
                            if (ptr + 2 > page_fixup_end) goto done_page;
                            fixup.target_offset = read_u16(ptr);
                            ptr += 2;
                        }
                    }
                    break;
                }

                case 0x01: {  // IMPORT_ORDINAL
                    // Module ordinal
                    if (ordinal_16bit) {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.module_ordinal = read_u16(ptr);
                        ptr += 2;
                    } else if (ordinal_8bit) {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.module_ordinal = *ptr++;
                    } else {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.module_ordinal = *ptr++;
                    }

                    // Import ordinal
                    if (ordinal_16bit) {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.import_ordinal = read_u16(ptr);
                        ptr += 2;
                    } else if (ordinal_8bit) {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.import_ordinal = *ptr++;
                    } else {
                        if (target_32bit) {
                            if (ptr + 4 > page_fixup_end) goto done_page;
                            fixup.import_ordinal = read_u32(ptr);
                            ptr += 4;
                        } else {
                            if (ptr + 2 > page_fixup_end) goto done_page;
                            fixup.import_ordinal = read_u16(ptr);
                            ptr += 2;
                        }
                    }
                    break;
                }

                case 0x02: {  // IMPORT_NAME
                    // Module ordinal
                    if (ordinal_16bit) {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.module_ordinal = read_u16(ptr);
                        ptr += 2;
                    } else if (ordinal_8bit) {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.module_ordinal = *ptr++;
                    } else {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.module_ordinal = *ptr++;
                    }

                    // Procedure name table offset
                    if (target_32bit) {
                        if (ptr + 4 > page_fixup_end) goto done_page;
                        fixup.target_offset = read_u32(ptr);  // Offset into import proc table
                        ptr += 4;
                    } else {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.target_offset = read_u16(ptr);
                        ptr += 2;
                    }
                    break;
                }

                case 0x03: {  // INTERNAL_ENTRY
                    // Entry ordinal
                    if (ordinal_16bit) {
                        if (ptr + 2 > page_fixup_end) goto done_page;
                        fixup.import_ordinal = read_u16(ptr);  // Entry ordinal
                        ptr += 2;
                    } else if (ordinal_8bit) {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.import_ordinal = *ptr++;
                    } else {
                        if (ptr >= page_fixup_end) goto done_page;
                        fixup.import_ordinal = *ptr++;
                    }
                    break;
                }
            }

            // Read additive value if present
            if (additive) {
                if (additive_32bit) {
                    if (ptr + 4 > page_fixup_end) goto done_page;
                    fixup.additive_value = static_cast<int32_t>(read_u32(ptr));
                    ptr += 4;
                } else {
                    if (ptr + 2 > page_fixup_end) goto done_page;
                    fixup.additive_value = static_cast<int16_t>(read_u16(ptr));
                    ptr += 2;
                }
            }

            // Add a fixup entry for each source offset
            for (uint16_t offset : source_offsets) {
                le_fixup f = fixup;
                f.source_offset = offset;
                fixups_.push_back(f);
            }
        }
        done_page:;
    }
}

void le_file::parse_resource_table() {
    // Resource table is optional - many LE/LX files don't have resources
    if (resource_table_offset_ == 0 || resource_count_ == 0) {
        return;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + resource_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    // Each resource entry is 14 bytes (see le_resource_entry in DataScript)
    const size_t entry_size = 14;

    resources_.reserve(resource_count_);

    for (uint32_t i = 0; i < resource_count_; ++i) {
        if (ptr + entry_size > end) {
            diagnostics_.warning(diagnostic_code::LE_INVALID_OBJECT_INDEX,
                                "Resource table truncated");
            break;
        }

        // Parse resource entry manually (DataScript struct is 14 bytes)
        // uint16 type_id, uint16 name_id, uint32 size, uint16 object, uint32 offset
        le_resource res;
        res.type_id = static_cast<uint16_t>(ptr[0]) |
                     (static_cast<uint16_t>(ptr[1]) << 8);
        res.name_id = static_cast<uint16_t>(ptr[2]) |
                     (static_cast<uint16_t>(ptr[3]) << 8);
        res.size = static_cast<uint32_t>(ptr[4]) |
                  (static_cast<uint32_t>(ptr[5]) << 8) |
                  (static_cast<uint32_t>(ptr[6]) << 16) |
                  (static_cast<uint32_t>(ptr[7]) << 24);
        res.object = static_cast<uint16_t>(ptr[8]) |
                    (static_cast<uint16_t>(ptr[9]) << 8);
        res.offset = static_cast<uint32_t>(ptr[10]) |
                    (static_cast<uint32_t>(ptr[11]) << 8) |
                    (static_cast<uint32_t>(ptr[12]) << 16) |
                    (static_cast<uint32_t>(ptr[13]) << 24);

        resources_.push_back(res);
        ptr += entry_size;
    }
}

// Base class interface
format_type le_file::get_format() const {
    if (is_lx_) {
        return is_bound_ ? format_type::LX_OS2_BOUND : format_type::LX_OS2_RAW;
    }

    // Check for VxD
    if (os_type_ == 0x02) {  // Windows (VxD)
        return format_type::LE_VXD;
    }

    return is_bound_ ? format_type::LE_DOS32_BOUND : format_type::LE_DOS32_RAW;
}

std::string_view le_file::format_name() const {
    switch (get_format()) {
        case format_type::LE_DOS32_BOUND:
            return "LE (32-bit DOS with extender)";
        case format_type::LE_DOS32_RAW:
            return "LE (32-bit DOS raw)";
        case format_type::LE_VXD:
            return "LE (Windows VxD)";
        case format_type::LX_OS2_BOUND:
            return "LX (OS/2 with stub)";
        case format_type::LX_OS2_RAW:
            return "LX (OS/2 raw)";
        default:
            return "LE/LX";
    }
}

std::span<const uint8_t> le_file::code_section() const {
    auto code_obj = get_code_object();
    if (!code_obj) {
        return {};
    }

    // Find pages for this object
    auto pages = get_object_pages(code_obj->index);
    if (pages.empty()) {
        return {};
    }

    // Return span to first page data
    const auto& first_page = pages[0];
    if (first_page.file_offset >= data_->size()) {
        return {};
    }

    size_t available = data_->size() - first_page.file_offset;
    size_t size = std::min(static_cast<size_t>(code_obj->virtual_size), available);

    return std::span<const uint8_t>(data_->data() + first_page.file_offset, size);
}

// Format identification
bool le_file::is_lx() const { return is_lx_; }

bool le_file::is_vxd() const {
    return os_type_ == 0x02;  // Windows (VxD)
}

bool le_file::is_library() const {
    return (module_flags_ & 0x00008000) != 0;  // LIBRARY flag
}

bool le_file::is_bound() const { return is_bound_; }

dos_extender_type le_file::extender_type() const { return extender_type_; }

// Header accessors
uint16_t le_file::cpu_type() const { return cpu_type_; }
uint16_t le_file::os_type() const { return os_type_; }
uint32_t le_file::module_version() const { return module_version_; }
uint32_t le_file::module_flags() const { return module_flags_; }
uint32_t le_file::page_size() const { return page_size_; }
uint32_t le_file::page_offset_shift() const { return page_offset_shift_; }
size_t le_file::page_count() const { return page_count_; }
size_t le_file::preload_page_count() const { return preload_page_count_; }
uint32_t le_file::heap_size() const { return heap_size_; }
uint32_t le_file::stack_size() const { return stack_size_; }
uint32_t le_file::auto_data_object() const { return auto_data_object_; }
uint32_t le_file::instance_preload_pages() const { return instance_preload_; }
uint32_t le_file::instance_demand_pages() const { return instance_demand_; }

// Entry point
uint32_t le_file::entry_eip() const { return eip_; }
uint32_t le_file::entry_object() const { return eip_object_; }
uint32_t le_file::entry_esp() const { return esp_; }
uint32_t le_file::stack_object() const { return esp_object_; }

// Object access
const std::vector<le_object>& le_file::objects() const { return objects_; }

std::optional<le_object> le_file::get_object(uint32_t index) const {
    if (index == 0 || index > objects_.size()) {
        return std::nullopt;
    }
    return objects_[index - 1];  // Convert to 0-based
}

std::optional<le_object> le_file::get_code_object() const {
    for (const auto& obj : objects_) {
        if (obj.is_executable()) {
            return obj;
        }
    }
    return std::nullopt;
}

std::optional<le_object> le_file::get_data_object() const {
    for (const auto& obj : objects_) {
        if (!obj.is_executable() && obj.is_readable()) {
            return obj;
        }
    }
    return std::nullopt;
}

std::optional<le_object> le_file::get_entry_object() const {
    return get_object(eip_object_);
}

std::vector<le_page_entry> le_file::get_object_pages(uint32_t object_index) const {
    auto obj = get_object(object_index);
    if (!obj) {
        return {};
    }

    std::vector<le_page_entry> result;
    uint32_t start_idx = obj->page_table_index - 1;  // Convert to 0-based
    uint32_t end_idx = start_idx + obj->page_count;

    for (uint32_t i = start_idx; i < end_idx && i < page_table_.size(); ++i) {
        result.push_back(page_table_[i]);
    }

    return result;
}

std::vector<uint8_t> le_file::read_object_data(uint32_t object_index) const {
    auto obj = get_object(object_index);
    if (!obj) {
        return {};
    }

    std::vector<uint8_t> result;
    result.reserve(obj->virtual_size);

    // Temporary buffer for page decompression (must be at least 4096 bytes)
    uint8_t page_buffer[4096];

    auto pages = get_object_pages(object_index);
    for (const auto& page : pages) {
        if (page.is_zerofill()) {
            // Zero-fill page
            size_t fill_size = std::min(static_cast<size_t>(page_size_),
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.resize(result.size() + fill_size, 0);
        } else if (page.is_invalid()) {
            // Invalid page - zero-fill
            size_t fill_size = std::min(static_cast<size_t>(page_size_),
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.resize(result.size() + fill_size, 0);
        } else if (page.is_iterated() && page.file_offset < data_->size()) {
            // EXEPACK1 compressed page (iterated/run-length encoded)
            size_t input_size = std::min(static_cast<size_t>(page.data_size),
                                        data_->size() - page.file_offset);
            size_t output_size = lx_unpack1(data_->data() + page.file_offset,
                                           input_size, page_buffer);
            size_t copy_size = std::min(output_size,
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.insert(result.end(), page_buffer, page_buffer + copy_size);
        } else if (page.is_compressed() && page.file_offset < data_->size()) {
            // EXEPACK2 compressed page (Lempel-Ziv variant)
            size_t input_size = std::min(static_cast<size_t>(page.data_size),
                                        data_->size() - page.file_offset);
            size_t output_size = lx_unpack2(data_->data() + page.file_offset,
                                           input_size, page_buffer);
            size_t copy_size = std::min(output_size,
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.insert(result.end(), page_buffer, page_buffer + copy_size);
        } else if (page.file_offset < data_->size()) {
            // Legal uncompressed page - copy data directly
            size_t copy_size = std::min(static_cast<size_t>(page.data_size),
                                       data_->size() - page.file_offset);
            copy_size = std::min(copy_size,
                                static_cast<size_t>(obj->virtual_size - result.size()));
            result.insert(result.end(),
                         data_->begin() + page.file_offset,
                         data_->begin() + page.file_offset + copy_size);
        }
    }

    return result;
}

// Name tables
std::vector<le_name_entry> le_file::resident_names() const {
    std::vector<le_name_entry> result;

    if (resident_name_table_offset_ == 0) {
        return result;
    }

    const uint8_t* ptr = data_->data() + le_header_offset_ + resident_name_table_offset_;
    const uint8_t* end = data_->data() + data_->size();

    while (ptr < end) {
        uint8_t len = *ptr++;
        if (len == 0) {
            break;  // End of table
        }

        if (ptr + len + 2 > end) {
            break;
        }

        le_name_entry entry;
        entry.name = std::string(reinterpret_cast<const char*>(ptr), len);
        ptr += len;

        entry.ordinal = static_cast<uint16_t>(ptr[0]) |
                       (static_cast<uint16_t>(ptr[1]) << 8);
        ptr += 2;

        result.push_back(std::move(entry));
    }

    return result;
}

std::vector<le_name_entry> le_file::nonresident_names() const {
    std::vector<le_name_entry> result;

    if (nonresident_name_table_offset_ == 0 || nonresident_name_table_size_ == 0) {
        return result;
    }

    if (nonresident_name_table_offset_ >= data_->size()) {
        return result;
    }

    const uint8_t* ptr = data_->data() + nonresident_name_table_offset_;
    const uint8_t* table_end = ptr + std::min(static_cast<size_t>(nonresident_name_table_size_),
                                              data_->size() - nonresident_name_table_offset_);
    const uint8_t* end = data_->data() + data_->size();

    while (ptr < table_end && ptr < end) {
        uint8_t len = *ptr++;
        if (len == 0) {
            break;  // End of table
        }

        if (ptr + len + 2 > end) {
            break;
        }

        le_name_entry entry;
        entry.name = std::string(reinterpret_cast<const char*>(ptr), len);
        ptr += len;

        entry.ordinal = static_cast<uint16_t>(ptr[0]) |
                       (static_cast<uint16_t>(ptr[1]) << 8);
        ptr += 2;

        result.push_back(std::move(entry));
    }

    return result;
}

std::string le_file::module_name() const {
    auto names = resident_names();
    if (!names.empty()) {
        return names[0].name;  // First entry is module name
    }
    return "";
}

// Entry table
const std::vector<le_entry>& le_file::entries() const { return entries_; }

std::optional<le_entry> le_file::get_entry(uint16_t ordinal) const {
    for (const auto& entry : entries_) {
        if (entry.ordinal == ordinal) {
            return entry;
        }
    }
    return std::nullopt;
}

size_t le_file::entry_count() const { return entries_.size(); }

// Import tables
const std::vector<std::string>& le_file::import_modules() const { return import_modules_; }

size_t le_file::import_module_count() const { return import_modules_.size(); }

std::optional<std::string> le_file::get_import_module(uint16_t index) const {
    if (index == 0 || index > import_modules_.size()) {
        return std::nullopt;
    }
    return import_modules_[index - 1];  // Convert to 0-based
}

// Fixup tables
const std::vector<le_fixup>& le_file::fixups() const { return fixups_; }

std::vector<le_fixup> le_file::get_page_fixups(uint32_t page_index) const {
    std::vector<le_fixup> result;
    for (const auto& fixup : fixups_) {
        if (fixup.page_index == page_index) {
            result.push_back(fixup);
        }
    }
    return result;
}

size_t le_file::fixup_count() const { return fixups_.size(); }

bool le_file::has_fixups() const { return !fixups_.empty(); }

// Resource table
const std::vector<le_resource>& le_file::resources() const { return resources_; }

size_t le_file::resource_count() const { return resources_.size(); }

bool le_file::has_resources() const { return !resources_.empty(); }

std::vector<le_resource> le_file::resources_by_type(uint16_t type_id) const {
    std::vector<le_resource> result;
    for (const auto& res : resources_) {
        if (res.type_id == type_id) {
            result.push_back(res);
        }
    }
    return result;
}

std::optional<le_resource> le_file::get_resource(uint16_t type_id, uint16_t name_id) const {
    for (const auto& res : resources_) {
        if (res.type_id == type_id && res.name_id == name_id) {
            return res;
        }
    }
    return std::nullopt;
}

std::vector<uint8_t> le_file::read_resource_data(const le_resource& resource) const {
    // Get the object containing the resource
    auto obj = get_object(resource.object);
    if (!obj) {
        return {};
    }

    // Read object data
    auto obj_data = read_object_data(resource.object);
    if (obj_data.empty()) {
        return {};
    }

    // Extract resource data at the specified offset
    if (resource.offset >= obj_data.size()) {
        return {};
    }

    size_t available = obj_data.size() - resource.offset;
    size_t copy_size = std::min(static_cast<size_t>(resource.size), available);

    return std::vector<uint8_t>(
        obj_data.begin() + resource.offset,
        obj_data.begin() + resource.offset + copy_size
    );
}

// =============================================================================
// Module Flag Analysis
// =============================================================================

bool le_file::has_per_process_init() const {
    return (module_flags_ & 0x00000004) != 0;
}

bool le_file::has_per_process_term() const {
    return (module_flags_ & 0x40000000) != 0;
}

bool le_file::has_internal_fixups() const {
    return (module_flags_ & 0x00000010) != 0;
}

bool le_file::has_external_fixups() const {
    return (module_flags_ & 0x00000020) != 0;
}

bool le_file::is_pm_compatible() const {
    uint32_t pm_bits = (module_flags_ >> 8) & 0x3;
    return pm_bits == 1 || pm_bits == 3;  // PM_COMPATIBLE or PM_USES_API
}

bool le_file::uses_pm_api() const {
    uint32_t pm_bits = (module_flags_ >> 8) & 0x3;
    return pm_bits == 3;  // PM_USES_API
}

bool le_file::is_not_loadable() const {
    return (module_flags_ & 0x00002000) != 0;
}

bool le_file::is_mp_safe() const {
    // MP_UNSAFE flag means NOT safe
    return (module_flags_ & 0x00080000) == 0;
}

// =============================================================================
// Entropy Analysis
// =============================================================================

double le_file::file_entropy() const {
    return entropy_calculator::calculate(data_->span());
}

double le_file::object_entropy(uint32_t object_index) const {
    auto data = read_object_data(object_index);
    if (data.empty()) {
        return 0.0;
    }
    return entropy_calculator::calculate(data);
}

std::vector<std::pair<uint32_t, double>> le_file::all_object_entropies() const {
    std::vector<std::pair<uint32_t, double>> result;
    result.reserve(objects_.size());

    for (const auto& obj : objects_) {
        auto data = read_object_data(obj.index);
        double entropy = data.empty() ? 0.0 : entropy_calculator::calculate(data);
        result.emplace_back(obj.index, entropy);
    }

    return result;
}

bool le_file::has_high_entropy_objects() const {
    for (const auto& obj : objects_) {
        // Only check executable or readable objects
        if (!obj.is_readable()) continue;

        auto data = read_object_data(obj.index);
        if (!data.empty()) {
            double entropy = entropy_calculator::calculate(data);
            if (entropy >= entropy_calculator::HIGH_ENTROPY_THRESHOLD) {
                return true;
            }
        }
    }
    return false;
}

bool le_file::is_likely_packed() const {
    // Check if most pages are compressed (LX specific)
    if (is_lx_) {
        size_t compressed_pages = 0;
        size_t iterated_pages = 0;
        for (const auto& page : page_table_) {
            if (page.is_compressed()) compressed_pages++;
            if (page.is_iterated()) iterated_pages++;
        }

        // If >50% of pages are compressed/iterated, likely packed
        if (page_table_.size() > 0) {
            double compression_ratio = static_cast<double>(compressed_pages + iterated_pages) /
                                      static_cast<double>(page_table_.size());
            if (compression_ratio > 0.5) {
                return true;
            }
        }
    }

    // Check entropy of executable objects
    for (const auto& obj : objects_) {
        if (!obj.is_executable()) continue;

        auto data = read_object_data(obj.index);
        if (!data.empty()) {
            double entropy = entropy_calculator::calculate(data);
            // Very high entropy in code section suggests packing
            if (entropy >= entropy_calculator::VERY_HIGH_ENTROPY_THRESHOLD) {
                return true;
            }
        }
    }

    return false;
}

// =============================================================================
// Debug information
// =============================================================================

bool le_file::has_debug_info() const {
    return debug_info_offset_ != 0 && debug_info_size_ != 0;
}

uint32_t le_file::debug_info_offset() const { return debug_info_offset_; }
uint32_t le_file::debug_info_size() const { return debug_info_size_; }

// DOS Extender Stripping
uint32_t le_file::le_header_offset() const { return le_header_offset_; }
uint32_t le_file::stub_size() const { return le_header_offset_; }

std::vector<uint8_t> le_file::strip_extender() const {
    // If not bound, return empty - no stripping needed
    if (!is_bound_ || le_header_offset_ == 0) {
        return {};
    }

    // Calculate output size
    if (le_header_offset_ >= data_->size()) {
        return {};
    }
    size_t output_size = data_->size() - le_header_offset_;

    // Copy from LE header to end
    std::vector<uint8_t> output(data_->begin() + le_header_offset_, data_->end());

    // Helper functions to read/write little-endian 32-bit values
    auto read_u32 = [](const std::vector<uint8_t>& data, size_t offset) -> uint32_t {
        if (offset + 4 > data.size()) return 0;
        return static_cast<uint32_t>(data[offset]) |
               (static_cast<uint32_t>(data[offset + 1]) << 8) |
               (static_cast<uint32_t>(data[offset + 2]) << 16) |
               (static_cast<uint32_t>(data[offset + 3]) << 24);
    };

    auto write_u32 = [](std::vector<uint8_t>& data, size_t offset, uint32_t value) {
        if (offset + 4 > data.size()) return;
        data[offset] = static_cast<uint8_t>(value & 0xFF);
        data[offset + 1] = static_cast<uint8_t>((value >> 8) & 0xFF);
        data[offset + 2] = static_cast<uint8_t>((value >> 16) & 0xFF);
        data[offset + 3] = static_cast<uint8_t>((value >> 24) & 0xFF);
    };

    // Verify this is LE or LX format (not LC which has different semantics)
    uint16_t magic = static_cast<uint16_t>(output[0]) |
                     (static_cast<uint16_t>(output[1]) << 8);

    if (magic == 0x454C || magic == 0x584C) {  // LE or LX
        // Adjust absolute file offsets:
        // Offset 0x80: DataPagesOffsetFromTopOfFile (always adjust)
        uint32_t data_pages = read_u32(output, 0x80);
        if (data_pages >= le_header_offset_) {
            data_pages -= le_header_offset_;
            write_u32(output, 0x80, data_pages);
        }

        // Offset 0x88: NonResidentNamesTableOffset (adjust if non-zero)
        uint32_t nonres = read_u32(output, 0x88);
        if (nonres != 0 && nonres >= le_header_offset_) {
            nonres -= le_header_offset_;
            write_u32(output, 0x88, nonres);
        }

        // Offset 0x98: DebugInformationOffset (adjust if non-zero)
        uint32_t debug = read_u32(output, 0x98);
        if (debug != 0 && debug >= le_header_offset_) {
            debug -= le_header_offset_;
            write_u32(output, 0x98, debug);
        }
    }
    // LC format doesn't need offset adjustment (uses different semantics)

    return output;
}

// Diagnostics
const diagnostic_collector& le_file::diagnostics() const { return diagnostics_; }

bool le_file::has_diagnostic(diagnostic_code code) const {
    return diagnostics_.has_code(code);
}

} // namespace libexe
