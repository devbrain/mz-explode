// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/le_file.hpp>
#include "libexe_format_mz.hh"   // Generated by DataScript (modular)
#include "libexe_format_le.hh"  // Generated by DataScript (modular)
#include <fstream>
#include <stdexcept>
#include <cstring>
#include <algorithm>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
le_file le_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

le_file le_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 2) {
        throw std::runtime_error("File too small to be a valid LE/LX executable");
    }

    le_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_le_headers();
        file.parse_objects();
        file.parse_page_table();
    } catch (const formats::le::le_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid LE/LX file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing LE/LX file: ") + e.what());
    }

    return file;
}

void le_file::parse_le_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Check for raw LE/LX (starts with 'LE' or 'LX')
    uint16_t first_sig = formats::le::le_header::read_uint16_le(ptr, end);
    ptr -= 2;  // Rewind

    if (first_sig == 0x454C || first_sig == 0x584C) {
        // Raw LE/LX - no MZ stub
        is_bound_ = false;
        le_header_offset_ = 0;
        extender_type_ = dos_extender_type::NONE;
    } else if (first_sig == 0x5A4D) {
        // MZ header present - parse DOS header to get LE offset
        auto dos_header = formats::mz::image_dos_header::read(ptr, end);
        le_header_offset_ = dos_header.e_lfanew;

        if (le_header_offset_ == 0 || le_header_offset_ >= data_.size() - 4) {
            throw std::runtime_error("Invalid e_lfanew offset in MZ header");
        }

        is_bound_ = true;
        detect_extender_type();
    } else {
        throw std::runtime_error("Not a valid LE/LX file (invalid signature)");
    }

    // Parse LE/LX header
    ptr = data_.data() + le_header_offset_;
    auto le_header = formats::le::le_header::image_le_header::read(ptr, end);

    // Validate signature
    uint16_t sig = le_header.le_magic;
    if (sig == 0x454C) {
        is_lx_ = false;
    } else if (sig == 0x584C) {
        is_lx_ = true;
    } else {
        throw std::runtime_error("Invalid LE/LX signature");
    }

    // Extract header fields
    cpu_type_ = static_cast<uint16_t>(le_header.cpu_type);
    os_type_ = static_cast<uint16_t>(le_header.os_type);
    module_version_ = le_header.module_version;
    module_flags_ = static_cast<uint32_t>(le_header.module_flags);
    page_count_ = le_header.page_count;
    page_size_ = le_header.page_size;
    page_offset_shift_ = le_header.page_offset_shift;

    // Entry point
    eip_object_ = le_header.eip_object;
    eip_ = le_header.eip;
    esp_object_ = le_header.esp_object;
    esp_ = le_header.esp;

    // Table offsets (relative to LE header)
    object_table_offset_ = le_header.object_table_offset;
    object_count_ = le_header.object_count;
    page_table_offset_ = le_header.object_page_table_offset;
    resident_name_table_offset_ = le_header.resident_name_table_offset;
    entry_table_offset_ = le_header.entry_table_offset;

    // Absolute file offsets
    data_pages_offset_ = le_header.data_pages_offset;
    nonresident_name_table_offset_ = le_header.nonresident_name_table_offset;
    nonresident_name_table_size_ = le_header.nonresident_name_table_size;
    debug_info_offset_ = le_header.debug_info_offset;
    debug_info_size_ = le_header.debug_info_size;
}

void le_file::detect_extender_type() {
    // Try to detect DOS extender type from the MZ stub
    // Common signatures at specific offsets

    // DOS/32A signatures
    if (data_.size() > 0x80) {
        // Check for "DOS/32A" string
        auto find_signature = [this](const char* sig, size_t sig_len) {
            auto it = std::search(data_.begin(), data_.end(),
                                  sig, sig + sig_len);
            return it != data_.end();
        };

        if (find_signature("DOS/32A", 7)) {
            extender_type_ = dos_extender_type::DOS32A;
            return;
        }
        if (find_signature("STUB/32A", 8)) {
            extender_type_ = dos_extender_type::STUB32A;
            return;
        }
        if (find_signature("STUB/32C", 8)) {
            extender_type_ = dos_extender_type::STUB32C;
            return;
        }
        if (find_signature("DOS/4G", 6)) {
            extender_type_ = dos_extender_type::DOS4G;
            return;
        }
        if (find_signature("DOS4GW", 6) || find_signature("DOS/4GW", 7)) {
            extender_type_ = dos_extender_type::DOS4GW;
            return;
        }
        if (find_signature("PMODE/W", 7)) {
            extender_type_ = dos_extender_type::PMODEW;
            return;
        }
        if (find_signature("CauseWay", 8)) {
            extender_type_ = dos_extender_type::CAUSEWAY;
            return;
        }
        if (find_signature("WDOSX", 5)) {
            extender_type_ = dos_extender_type::WDOSX;
            return;
        }
        if (find_signature("CWSDPMI", 7)) {
            extender_type_ = dos_extender_type::CWSDPMI;
            return;
        }
    }

    extender_type_ = dos_extender_type::UNKNOWN;
}

void le_file::parse_objects() {
    if (object_count_ == 0) {
        return;
    }

    const uint8_t* ptr = data_.data() + le_header_offset_ + object_table_offset_;
    const uint8_t* end = data_.data() + data_.size();

    objects_.reserve(object_count_);

    for (uint32_t i = 0; i < object_count_; ++i) {
        if (ptr + 24 > end) {
            diagnostics_.warning(diagnostic_code::LE_INVALID_OBJECT_INDEX,
                                "Object table truncated");
            break;
        }

        auto entry = formats::le::le_header::le_object_table_entry::read(ptr, end);

        le_object obj;
        obj.index = i + 1;  // 1-based
        obj.virtual_size = entry.virtual_size;
        obj.base_address = entry.base_address;
        obj.flags = static_cast<uint32_t>(entry.flags);
        obj.page_table_index = entry.page_table_index;
        obj.page_count = entry.page_count;

        objects_.push_back(obj);
    }
}

void le_file::parse_page_table() {
    // Calculate total pages needed
    uint32_t total_pages = 0;
    for (const auto& obj : objects_) {
        total_pages += obj.page_count;
    }

    if (total_pages == 0) {
        return;
    }

    const uint8_t* ptr = data_.data() + le_header_offset_ + page_table_offset_;
    const uint8_t* end = data_.data() + data_.size();

    page_table_.reserve(total_pages);

    for (uint32_t i = 0; i < total_pages; ++i) {
        le_page_entry page;
        page.page_number = i + 1;

        if (is_lx_) {
            // LX format: 8-byte page entries
            if (ptr + 8 > end) {
                diagnostics_.warning(diagnostic_code::LE_INVALID_PAGE_OFFSET,
                                    "Page table truncated");
                break;
            }

            auto entry = formats::le::le_header::lx_page_table_entry::read(ptr, end);
            // LX: offset is shifted by page_offset_shift
            page.file_offset = data_pages_offset_ +
                              (entry.offset << page_offset_shift_);
            page.data_size = entry.data_size;
            page.flags = static_cast<uint16_t>(entry.flags);
        } else {
            // LE format: 4-byte page entries
            if (ptr + 4 > end) {
                diagnostics_.warning(diagnostic_code::LE_INVALID_PAGE_OFFSET,
                                    "Page table truncated");
                break;
            }

            auto entry = formats::le::le_header::le_page_table_entry::read(ptr, end);
            // LE: 24-bit offset stored as high/med/low bytes
            uint32_t page_num = (static_cast<uint32_t>(entry.high) << 16) |
                               (static_cast<uint32_t>(entry.med) << 8) |
                               static_cast<uint32_t>(entry.low);
            // LE: offset is (page_number - 1) * page_size from data_pages_offset
            if (page_num > 0) {
                page.file_offset = data_pages_offset_ + (page_num - 1) * page_size_;
            } else {
                page.file_offset = 0;
            }
            page.data_size = static_cast<uint16_t>(page_size_);
            page.flags = entry.flags;
        }

        page_table_.push_back(page);
    }
}

// Base class interface
format_type le_file::get_format() const {
    if (is_lx_) {
        return is_bound_ ? format_type::LX_OS2_BOUND : format_type::LX_OS2_RAW;
    }

    // Check for VxD
    if (os_type_ == 0x02) {  // Windows (VxD)
        return format_type::LE_VXD;
    }

    return is_bound_ ? format_type::LE_DOS32_BOUND : format_type::LE_DOS32_RAW;
}

std::string_view le_file::format_name() const {
    switch (get_format()) {
        case format_type::LE_DOS32_BOUND:
            return "LE (32-bit DOS with extender)";
        case format_type::LE_DOS32_RAW:
            return "LE (32-bit DOS raw)";
        case format_type::LE_VXD:
            return "LE (Windows VxD)";
        case format_type::LX_OS2_BOUND:
            return "LX (OS/2 with stub)";
        case format_type::LX_OS2_RAW:
            return "LX (OS/2 raw)";
        default:
            return "LE/LX";
    }
}

std::span<const uint8_t> le_file::code_section() const {
    auto code_obj = get_code_object();
    if (!code_obj) {
        return {};
    }

    // Find pages for this object
    auto pages = get_object_pages(code_obj->index);
    if (pages.empty()) {
        return {};
    }

    // Return span to first page data
    const auto& first_page = pages[0];
    if (first_page.file_offset >= data_.size()) {
        return {};
    }

    size_t available = data_.size() - first_page.file_offset;
    size_t size = std::min(static_cast<size_t>(code_obj->virtual_size), available);

    return std::span<const uint8_t>(data_.data() + first_page.file_offset, size);
}

// Format identification
bool le_file::is_lx() const { return is_lx_; }

bool le_file::is_vxd() const {
    return os_type_ == 0x02;  // Windows (VxD)
}

bool le_file::is_library() const {
    return (module_flags_ & 0x00008000) != 0;  // LIBRARY flag
}

bool le_file::is_bound() const { return is_bound_; }

dos_extender_type le_file::extender_type() const { return extender_type_; }

// Header accessors
uint16_t le_file::cpu_type() const { return cpu_type_; }
uint16_t le_file::os_type() const { return os_type_; }
uint32_t le_file::module_version() const { return module_version_; }
uint32_t le_file::module_flags() const { return module_flags_; }
uint32_t le_file::page_size() const { return page_size_; }
uint32_t le_file::page_offset_shift() const { return page_offset_shift_; }
uint32_t le_file::page_count() const { return page_count_; }

// Entry point
uint32_t le_file::entry_eip() const { return eip_; }
uint32_t le_file::entry_object() const { return eip_object_; }
uint32_t le_file::entry_esp() const { return esp_; }
uint32_t le_file::stack_object() const { return esp_object_; }

// Object access
const std::vector<le_object>& le_file::objects() const { return objects_; }

std::optional<le_object> le_file::get_object(uint32_t index) const {
    if (index == 0 || index > objects_.size()) {
        return std::nullopt;
    }
    return objects_[index - 1];  // Convert to 0-based
}

std::optional<le_object> le_file::get_code_object() const {
    for (const auto& obj : objects_) {
        if (obj.is_executable()) {
            return obj;
        }
    }
    return std::nullopt;
}

std::optional<le_object> le_file::get_data_object() const {
    for (const auto& obj : objects_) {
        if (!obj.is_executable() && obj.is_readable()) {
            return obj;
        }
    }
    return std::nullopt;
}

std::optional<le_object> le_file::get_entry_object() const {
    return get_object(eip_object_);
}

std::vector<le_page_entry> le_file::get_object_pages(uint32_t object_index) const {
    auto obj = get_object(object_index);
    if (!obj) {
        return {};
    }

    std::vector<le_page_entry> result;
    uint32_t start_idx = obj->page_table_index - 1;  // Convert to 0-based
    uint32_t end_idx = start_idx + obj->page_count;

    for (uint32_t i = start_idx; i < end_idx && i < page_table_.size(); ++i) {
        result.push_back(page_table_[i]);
    }

    return result;
}

std::vector<uint8_t> le_file::read_object_data(uint32_t object_index) const {
    auto obj = get_object(object_index);
    if (!obj) {
        return {};
    }

    std::vector<uint8_t> result;
    result.reserve(obj->virtual_size);

    auto pages = get_object_pages(object_index);
    for (const auto& page : pages) {
        if (page.is_zerofill()) {
            // Zero-fill page
            size_t fill_size = std::min(static_cast<size_t>(page_size_),
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.resize(result.size() + fill_size, 0);
        } else if (page.is_invalid()) {
            // Invalid page - skip or zero-fill?
            size_t fill_size = std::min(static_cast<size_t>(page_size_),
                                       static_cast<size_t>(obj->virtual_size - result.size()));
            result.resize(result.size() + fill_size, 0);
        } else if (page.file_offset < data_.size()) {
            // Legal page - copy data
            size_t copy_size = std::min(static_cast<size_t>(page.data_size),
                                       data_.size() - page.file_offset);
            copy_size = std::min(copy_size,
                                static_cast<size_t>(obj->virtual_size - result.size()));
            result.insert(result.end(),
                         data_.begin() + page.file_offset,
                         data_.begin() + page.file_offset + copy_size);
        }
    }

    return result;
}

// Name tables
std::vector<le_name_entry> le_file::resident_names() const {
    std::vector<le_name_entry> result;

    if (resident_name_table_offset_ == 0) {
        return result;
    }

    const uint8_t* ptr = data_.data() + le_header_offset_ + resident_name_table_offset_;
    const uint8_t* end = data_.data() + data_.size();

    while (ptr < end) {
        uint8_t len = *ptr++;
        if (len == 0) {
            break;  // End of table
        }

        if (ptr + len + 2 > end) {
            break;
        }

        le_name_entry entry;
        entry.name = std::string(reinterpret_cast<const char*>(ptr), len);
        ptr += len;

        entry.ordinal = static_cast<uint16_t>(ptr[0]) |
                       (static_cast<uint16_t>(ptr[1]) << 8);
        ptr += 2;

        result.push_back(std::move(entry));
    }

    return result;
}

std::vector<le_name_entry> le_file::nonresident_names() const {
    std::vector<le_name_entry> result;

    if (nonresident_name_table_offset_ == 0 || nonresident_name_table_size_ == 0) {
        return result;
    }

    if (nonresident_name_table_offset_ >= data_.size()) {
        return result;
    }

    const uint8_t* ptr = data_.data() + nonresident_name_table_offset_;
    const uint8_t* table_end = ptr + std::min(static_cast<size_t>(nonresident_name_table_size_),
                                              data_.size() - nonresident_name_table_offset_);
    const uint8_t* end = data_.data() + data_.size();

    while (ptr < table_end && ptr < end) {
        uint8_t len = *ptr++;
        if (len == 0) {
            break;  // End of table
        }

        if (ptr + len + 2 > end) {
            break;
        }

        le_name_entry entry;
        entry.name = std::string(reinterpret_cast<const char*>(ptr), len);
        ptr += len;

        entry.ordinal = static_cast<uint16_t>(ptr[0]) |
                       (static_cast<uint16_t>(ptr[1]) << 8);
        ptr += 2;

        result.push_back(std::move(entry));
    }

    return result;
}

std::string le_file::module_name() const {
    auto names = resident_names();
    if (!names.empty()) {
        return names[0].name;  // First entry is module name
    }
    return "";
}

// Debug information
bool le_file::has_debug_info() const {
    return debug_info_offset_ != 0 && debug_info_size_ != 0;
}

uint32_t le_file::debug_info_offset() const { return debug_info_offset_; }
uint32_t le_file::debug_info_size() const { return debug_info_size_; }

// Diagnostics
const diagnostic_collector& le_file::diagnostics() const { return diagnostics_; }

bool le_file::has_diagnostic(diagnostic_code code) const {
    return diagnostics_.has_code(code);
}

} // namespace libexe
