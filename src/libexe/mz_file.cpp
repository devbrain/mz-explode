// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/mz_file.hpp>
#include "ImageDosHeader.hh"  // Generated by DataScript
#include <fstream>
#include <stdexcept>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
mz_file mz_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

mz_file mz_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 28) {  // Minimum MZ header size
        throw std::runtime_error("File too small to be a valid MZ executable");
    }

    mz_file file;
    file.data_.assign(data.begin(), data.end());

    // Parse MZ header using DataScript-generated parser
    try {
        const uint8_t* ptr = file.data_.data();
        const uint8_t* end = ptr + file.data_.size();

        // Parse DOS header - will validate magic number automatically
        auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);

        // Calculate header size in bytes
        file.header_size_ = dos_header.e_cparhdr * 16;

        // Calculate code offset (start of actual program)
        file.code_offset_ = file.header_size_;

        // TODO: Detect compression type by examining code section
        file.compression_ = compression_type::NONE;

    } catch (const libexe::format::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid MZ file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing MZ file: ") + e.what());
    }

    return file;
}

// Interface implementation
format_type mz_file::get_format() const {
    return format_type::MZ_DOS;
}

std::string_view mz_file::format_name() const {
    return "MZ (DOS Executable)";
}

std::span<const uint8_t> mz_file::code_section() const {
    if (data_.size() > code_offset_) {
        return std::span<const uint8_t>(
            data_.data() + code_offset_,
            data_.size() - code_offset_
        );
    }
    return std::span<const uint8_t>();
}

// Compression detection
bool mz_file::is_compressed() const {
    return compression_ != compression_type::NONE;
}

compression_type mz_file::get_compression() const {
    return compression_;
}

// DOS header accessors
uint16_t mz_file::initial_cs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_cs;
}

uint16_t mz_file::initial_ip() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_ip;
}

uint16_t mz_file::initial_ss() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_ss;
}

uint16_t mz_file::initial_sp() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_sp;
}

uint16_t mz_file::min_extra_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_minalloc;
}

uint16_t mz_file::max_extra_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_maxalloc;
}

uint16_t mz_file::relocation_count() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_crlc;
}

uint16_t mz_file::header_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);
    return dos_header.e_cparhdr;
}

} // namespace libexe
