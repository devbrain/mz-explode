// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/mz_file.hpp>
#include "libexe_format_mz.hh"  // Generated by DataScript (modular)
#include <fstream>
#include <stdexcept>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
mz_file mz_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

mz_file mz_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 28) {  // Minimum MZ header size
        throw std::runtime_error("File too small to be a valid MZ executable");
    }

    mz_file file;
    file.data_.assign(data.begin(), data.end());

    // Parse MZ header using DataScript-generated parser
    try {
        const uint8_t* ptr = file.data_.data();
        const uint8_t* end = ptr + file.data_.size();

        // Parse DOS header - will validate magic number automatically
        auto dos_header = formats::mz::image_dos_header::read(ptr, end);

        // Calculate header size in bytes
        file.header_size_ = dos_header.e_cparhdr * 16;

        // Calculate code offset (start of actual program)
        file.code_offset_ = file.header_size_;

        // Detect compression type by examining code section
        file.compression_ = file.detect_compression();

    } catch (const formats::mz::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid MZ file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing MZ file: ") + e.what());
    }

    return file;
}

// Interface implementation
format_type mz_file::get_format() const {
    return format_type::MZ_DOS;
}

std::string_view mz_file::format_name() const {
    return "MZ (DOS Executable)";
}

std::span<const uint8_t> mz_file::code_section() const {
    if (data_.size() > code_offset_) {
        return {
            data_.data() + code_offset_,
            data_.size() - code_offset_
        };
    }
    return {};
}

// Compression detection
bool mz_file::is_compressed() const {
    return compression_ != compression_type::NONE;
}

compression_type mz_file::get_compression() const {
    return compression_;
}

// DOS header accessors
uint16_t mz_file::initial_cs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_cs;
}

uint16_t mz_file::initial_ip() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_ip;
}

uint16_t mz_file::initial_ss() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_ss;
}

uint16_t mz_file::initial_sp() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_sp;
}

uint16_t mz_file::min_extra_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_minalloc;
}

uint16_t mz_file::max_extra_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_maxalloc;
}

uint16_t mz_file::relocation_count() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_crlc;
}

uint16_t mz_file::header_paragraphs() const {
    if (data_.size() < 28) return 0;
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);
    return dos_header.e_cparhdr;
}

// Private methods

compression_type mz_file::detect_compression() const {
    // Need at least header + some code to detect compression
    if (data_.size() < header_size_ + 64) {
        return compression_type::NONE;
    }

    // PKLITE detection: "PKLI" signature at offset 0x1E
    static constexpr size_t pklite_offset = 0x1E;
    if (data_.size() >= pklite_offset + 4) {
        if (data_[pklite_offset] == 0x50 &&     // 'P'
            data_[pklite_offset + 1] == 0x4B && // 'K'
            data_[pklite_offset + 2] == 0x4C && // 'L'
            data_[pklite_offset + 3] == 0x49) { // 'I'

            // Check h_pklite_info at offset 0x1C to distinguish standard vs extra
            if (data_.size() >= 0x1C + 2) {
                uint16_t h_pklite_info = data_[0x1C] | (data_[0x1D] << 8);
                // Based on empirical testing with known files:
                // - PKLITE standard (e.g., 1.12): bit 0x1000 is CLEAR (0x210C)
                // - PKLITE Extra (e.g., 1.15): bit 0x1000 is SET (0x310F)
                // Note: Legacy code's "extended" flag != "Extra" compression
                if ((h_pklite_info & 0x1000) != 0) {
                    return compression_type::PKLITE_EXTRA;
                } else {
                    return compression_type::PKLITE_STANDARD;
                }
            }
            // Default to standard if we can't read h_pklite_info
            return compression_type::PKLITE_STANDARD;
        }
    }

    // LZEXE detection: "LZ" signature variants
    // LZEXE 0.90: signature at offset 0x1C
    if (data_.size() >= 0x1C + 2) {
        if (data_[0x1C] == 0x4C && data_[0x1D] == 0x5A) {  // "LZ"
            // Check for v0.91 signature at different location
            if (data_.size() >= 0x1E + 4) {
                if (data_[0x1E] == 0x39 && data_[0x1F] == 0x31) {  // "91"
                    return compression_type::LZEXE_091;
                }
            }
            return compression_type::LZEXE_090;
        }
    }

    // EXEPACK detection: Check for "RB" signature in EXEPACK header
    // EXEPACK header is at CS:0000, signature can be at offset +14 (16-byte header) or +16 (18-byte header)
    if (data_.size() >= 0x18) {
        uint16_t e_cs = data_[0x16] | (data_[0x17] << 8);
        uint32_t cs_offset = header_size_ + (e_cs * 16);

        // Try 16-byte header variant first (signature at +14)
        if (data_.size() >= cs_offset + 16) {
            if (data_[cs_offset + 14] == 0x52 && data_[cs_offset + 15] == 0x42) {  // "RB"
                return compression_type::EXEPACK;
            }
        }
        // Try 18-byte header variant (signature at +16)
        if (data_.size() >= cs_offset + 18) {
            if (data_[cs_offset + 16] == 0x52 && data_[cs_offset + 17] == 0x42) {  // "RB"
                return compression_type::EXEPACK;
            }
        }
    }

    // Knowledge Dynamics detection: Check for characteristic signature at offset 0x200
    // Signature: 0xE9 0x99 0x00 (JMP instruction pattern)
    if (data_.size() >= 0x200 + 3) {
        if (data_[0x200] == 0xE9 &&
            data_[0x201] == 0x99 &&
            data_[0x202] == 0x00) {
            return compression_type::KNOWLEDGE_DYNAMICS;
        }
    }

    return compression_type::NONE;
}

} // namespace libexe
