// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/mz_file.hpp>
#include <libexe/core/entropy.hpp>
#include "core/utils.hpp"
#include <libexe/core/data_source.hpp>
#include <formats/mz/mz.hh>  // Generated by DataScript (modular)
#include <stdexcept>
#include <cstring>

namespace libexe {

// Special member functions
mz_file::mz_file() = default;
mz_file::~mz_file() = default;
mz_file::mz_file(mz_file&&) noexcept = default;
mz_file& mz_file::operator=(mz_file&&) noexcept = default;

// Factory methods
mz_file mz_file::from_file(const std::filesystem::path& path) {
    mz_file file;
    file.data_ = std::make_unique<mmap_data_source>(path);
    file.parse_header();
    return file;
}

mz_file mz_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 28) {  // Minimum MZ header size
        throw std::runtime_error("File too small to be a valid MZ executable");
    }

    mz_file file;
    file.data_ = std::make_unique<vector_data_source>(data);
    file.parse_header();
    return file;
}

mz_file mz_file::from_data_source(std::unique_ptr<data_source> source) {
    if (!source || source->size() < 28) {  // Minimum MZ header size
        throw std::runtime_error("File too small to be a valid MZ executable");
    }

    mz_file file;
    file.data_ = std::move(source);
    file.parse_header();
    return file;
}

void mz_file::parse_header() {
    // Parse MZ header using DataScript-generated parser
    try {
        const uint8_t* ptr = data_->data();
        const uint8_t* end = ptr + data_->size();

        // Parse DOS header - will validate magic number automatically
        auto dos_header = formats::mz::image_dos_header::read(ptr, end);

        // Cache all header fields (parse once, access many times)
        e_cparhdr_ = dos_header.e_cparhdr;
        e_cs_ = dos_header.e_cs;
        e_ip_ = dos_header.e_ip;
        e_ss_ = dos_header.e_ss;
        e_sp_ = dos_header.e_sp;
        e_minalloc_ = dos_header.e_minalloc;
        e_maxalloc_ = dos_header.e_maxalloc;
        e_crlc_ = dos_header.e_crlc;

        // Calculate header size in bytes
        header_size_ = dos_header.e_cparhdr * 16;

        // Calculate code offset (start of actual program)
        code_offset_ = header_size_;

        // Detect compression type by examining code section
        compression_ = detect_compression();

    } catch (const formats::mz::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid MZ file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing MZ file: ") + e.what());
    }
}

// Interface implementation
format_type mz_file::get_format() const {
    return format_type::MZ_DOS;
}

std::string_view mz_file::format_name() const {
    return "MZ (DOS Executable)";
}

std::span<const uint8_t> mz_file::code_section() const {
    if (data_->size() > code_offset_) {
        return {
            data_->data() + code_offset_,
            data_->size() - code_offset_
        };
    }
    return {};
}

// Compression detection
bool mz_file::is_compressed() const {
    return compression_ != compression_type::NONE;
}

compression_type mz_file::get_compression() const {
    return compression_;
}

// DOS header accessors (return cached values - parsed once during construction)
uint16_t mz_file::entry_cs() const { return e_cs_; }
uint16_t mz_file::entry_ip() const { return e_ip_; }
uint16_t mz_file::entry_ss() const { return e_ss_; }
uint16_t mz_file::entry_sp() const { return e_sp_; }
uint16_t mz_file::min_extra_paragraphs() const { return e_minalloc_; }
uint16_t mz_file::max_extra_paragraphs() const { return e_maxalloc_; }
uint16_t mz_file::relocation_count() const { return e_crlc_; }
uint16_t mz_file::header_paragraphs() const { return e_cparhdr_; }

// Private methods

compression_type mz_file::detect_compression() const {
    const auto& data = *data_;

    // Need at least header + some code to detect compression
    if (data.size() < static_cast<size_t>(header_size_) + 64) {
        return compression_type::NONE;
    }

    // PKLITE detection: "PKLI" signature at offset 0x1E
    static constexpr size_t pklite_offset = 0x1E;
    if (data.size() >= pklite_offset + 4) {
        if (data[pklite_offset] == 0x50 &&     // 'P'
            data[pklite_offset + 1] == 0x4B && // 'K'
            data[pklite_offset + 2] == 0x4C && // 'L'
            data[pklite_offset + 3] == 0x49) { // 'I'

            // Check h_pklite_info at offset 0x1C to distinguish standard vs extra
            if (data.size() >= 0x1C + 2) {
                uint16_t h_pklite_info = data[0x1C] | (data[0x1D] << 8);
                // Based on empirical testing with known files:
                // - PKLITE standard (e.g., 1.12): bit 0x1000 is CLEAR (0x210C)
                // - PKLITE Extra (e.g., 1.15): bit 0x1000 is SET (0x310F)
                // Note: Legacy code's "extended" flag != "Extra" compression
                if ((h_pklite_info & 0x1000) != 0) {
                    return compression_type::PKLITE_EXTRA;
                } else {
                    return compression_type::PKLITE_STANDARD;
                }
            }
            // Default to standard if we can't read h_pklite_info
            return compression_type::PKLITE_STANDARD;
        }
    }

    // LZEXE detection: "LZ" signature variants
    // LZEXE 0.90: signature at offset 0x1C
    if (data.size() >= 0x1C + 2) {
        if (data[0x1C] == 0x4C && data[0x1D] == 0x5A) {  // "LZ"
            // Check for v0.91 signature at different location
            if (data.size() >= 0x1E + 4) {
                if (data[0x1E] == 0x39 && data[0x1F] == 0x31) {  // "91"
                    return compression_type::LZEXE_091;
                }
            }
            return compression_type::LZEXE_090;
        }
    }

    // EXEPACK detection: Check for "RB" signature in EXEPACK header
    // EXEPACK header is at CS:0000, signature can be at offset +14 (16-byte header) or +16 (18-byte header)
    if (data.size() >= 0x18) {
        uint16_t e_cs = data[0x16] | (data[0x17] << 8);

        // Check for overflow before calculating cs_offset
        uint32_t segment_offset;
        if (!internal::safe_multiply(static_cast<uint32_t>(e_cs), 16u, segment_offset)) {
            return compression_type::NONE;  // Overflow would occur
        }
        uint32_t cs_offset;
        if (!internal::safe_add(header_size_, segment_offset, cs_offset)) {
            return compression_type::NONE;  // Overflow would occur
        }

        // Try 16-byte header variant first (signature at +14)
        if (data.size() >= cs_offset + 16) {
            if (data[cs_offset + 14] == 0x52 && data[cs_offset + 15] == 0x42) {  // "RB"
                return compression_type::EXEPACK;
            }
        }
        // Try 18-byte header variant (signature at +16)
        if (data.size() >= cs_offset + 18) {
            if (data[cs_offset + 16] == 0x52 && data[cs_offset + 17] == 0x42) {  // "RB"
                return compression_type::EXEPACK;
            }
        }
    }

    // Knowledge Dynamics detection: Check for characteristic signature at offset 0x200
    // Signature: 0xE9 0x99 0x00 (JMP instruction pattern)
    if (data.size() >= 0x200 + 3) {
        if (data[0x200] == 0xE9 &&
            data[0x201] == 0x99 &&
            data[0x202] == 0x00) {
            return compression_type::KNOWLEDGE_DYNAMICS;
        }
    }

    // DIET detection: Look for characteristic byte patterns
    // DIET EXE has specific signatures based on version
    if (data.size() >= 80) {
        // Check for the 8e db 8e c0 33 f6 33 ff b9 signature at various offsets
        // This is more reliable than checking for "dlz" which can be modified
        static const uint8_t sig_8edb[] = {0x8e, 0xdb, 0x8e, 0xc0, 0x33, 0xf6, 0x33, 0xff, 0xb9};

        uint16_t e_cparhdr = data[8] | (data[9] << 8);
        size_t codestart = static_cast<size_t>(e_cparhdr) * 16;

        // Check various offset patterns for different DIET versions
        auto check_diet_sig = [&](size_t offset) -> bool {
            if (codestart + offset + sizeof(sig_8edb) > data.size()) return false;
            return std::memcmp(data.data() + codestart + offset, sig_8edb, sizeof(sig_8edb)) == 0;
        };

        // v1.45f: signature at offset 77-32 = 45
        // v1.44:  signature at offset 72-32 = 40
        // v1.02:  signature at offset 52-32 = 20
        // v1.00:  signature at offset 55-32 = 23
        if (check_diet_sig(45) || check_diet_sig(40) || check_diet_sig(20) || check_diet_sig(23)) {
            return compression_type::DIET;
        }
    }

    return compression_type::NONE;
}

// =============================================================================
// Entropy Analysis
// =============================================================================

double mz_file::file_entropy() const {
    return entropy_calculator::calculate(data_->span());
}

double mz_file::code_entropy() const {
    auto code = code_section();
    if (code.empty()) {
        return 0.0;
    }
    return entropy_calculator::calculate(code);
}

bool mz_file::is_high_entropy() const {
    auto code = code_section();
    if (code.empty()) {
        return false;
    }
    return entropy_calculator::is_high_entropy(code);
}

bool mz_file::is_likely_packed() const {
    // If we already detected a known compression type, it's packed
    if (compression_ != compression_type::NONE) {
        return true;
    }

    // Check code section entropy for unknown packers
    auto code = code_section();
    if (!code.empty()) {
        double entropy = entropy_calculator::calculate(code);
        // Very high entropy suggests packing/encryption
        if (entropy >= entropy_calculator::VERY_HIGH_ENTROPY_THRESHOLD) {
            return true;
        }
    }

    return false;
}

} // namespace libexe
