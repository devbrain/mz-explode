// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/formats/ne_file.hpp>
#include <libexe/ne/segment_parser.hpp>
#include <libexe/resources/ne_resource_directory.hpp>
#include <libexe/core/entropy.hpp>
#include "core/file_utils.hpp"
#include <formats/mz/mz.hh>  // Generated by DataScript (modular)
#include <formats/ne/ne_header/ne_header.hh>  // Generated by DataScript (modular)
#include <stdexcept>
#include <algorithm>

namespace libexe {

// Factory methods
ne_file ne_file::from_file(const std::filesystem::path& path) {
    auto data = internal::read_file_to_memory(path);
    return from_memory(data);
}

ne_file ne_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS stub + NE header pointer
        throw std::runtime_error("File too small to be a valid NE executable");
    }

    ne_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_ne_headers();
        file.parse_segments();
    } catch (const formats::ne::ne_header::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid NE file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing NE file: ") + e.what());
    }

    return file;
}

void ne_file::parse_ne_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Parse DOS header to get e_lfanew (offset to NE header)
    auto dos_header = formats::mz::image_dos_header::read(ptr, end);

    if (dos_header.e_magic != 0x5A4D) {
        throw std::runtime_error("Not a valid DOS/NE file (invalid MZ signature)");
    }

    // Get offset to NE header
    ne_offset_ = dos_header.e_lfanew;
    if (ne_offset_ == 0 || ne_offset_ >= data_.size() - 2) {
        throw std::runtime_error("Not an NE file (e_lfanew invalid)");
    }

    // Parse NE header (DataScript will validate NE signature)
    ptr = data_.data() + ne_offset_;
    auto ne_header = formats::ne::ne_header::image_ne_header::read(ptr, end);

    // Extract header fields
    linker_ver_ = ne_header.ne_ver;
    linker_rev_ = ne_header.ne_rev;
    flags_ = ne_header.ne_flags;
    segment_count_ = ne_header.ne_cseg;
    module_count_ = ne_header.ne_cmod;
    target_os_ = ne_header.ne_exetyp;
    alignment_shift_ = ne_header.ne_align;

    // Extract entry point (CS:IP stored as 32-bit value)
    uint32_t csip = ne_header.ne_csip;
    entry_ip_ = static_cast<uint16_t>(csip & 0xFFFF);
    entry_cs_ = static_cast<uint16_t>((csip >> 16) & 0xFFFF);

    // Extract initial stack (SS:SP stored as 32-bit value)
    uint32_t sssp = ne_header.ne_sssp;
    initial_sp_ = static_cast<uint16_t>(sssp & 0xFFFF);
    initial_ss_ = static_cast<uint16_t>((sssp >> 16) & 0xFFFF);

    // Extract table offsets (relative to NE header start)
    segment_table_offset_ = ne_header.ne_segtab;
    resource_table_offset_ = ne_header.ne_rsrctab;
    resident_name_table_offset_ = ne_header.ne_restab;
    module_ref_table_offset_ = ne_header.ne_modtab;
    import_name_table_offset_ = ne_header.ne_imptab;
    nonresident_name_table_offset_ = ne_header.ne_nrestab;  // Absolute offset
}

void ne_file::parse_segments() {
    // Use ne_segment_parser for consistent segment parsing
    segments_ = ne_segment_parser::parse_segments(
        data_,
        ne_offset_,
        segment_table_offset_,
        segment_count_,
        alignment_shift_
    );
}

// Interface implementation
format_type ne_file::get_format() const {
    return format_type::NE_WIN16;
}

std::string_view ne_file::format_name() const {
    // Determine specific OS target
    switch (target_os()) {
        case ne_target_os::OS2:     return "NE (OS/2)";
        case ne_target_os::WINDOWS: return "NE (Windows 16-bit)";
        case ne_target_os::DOS4:    return "NE (European MS-DOS 4.x)";
        case ne_target_os::WIN386:  return "NE (Windows 386)";
        case ne_target_os::BOSS:    return "NE (BOSS - Borland Operating System Services)";
        default:                    return "NE (Unknown target)";
    }
}

std::span<const uint8_t> ne_file::code_section() const {
    auto code_seg = get_code_segment();
    if (code_seg) {
        return code_seg->data;
    }
    return std::span<const uint8_t>();
}

// NE-specific accessors
uint8_t ne_file::linker_version() const {
    return linker_ver_;
}

uint8_t ne_file::linker_revision() const {
    return linker_rev_;
}

ne_file_flags ne_file::flags() const {
    return static_cast<ne_file_flags>(flags_);
}

uint16_t ne_file::segment_count() const {
    return segment_count_;
}

uint16_t ne_file::module_count() const {
    return module_count_;
}

ne_target_os ne_file::target_os() const {
    return static_cast<ne_target_os>(target_os_);
}

uint16_t ne_file::entry_cs() const {
    return entry_cs_;
}

uint16_t ne_file::entry_ip() const {
    return entry_ip_;
}

uint16_t ne_file::initial_ss() const {
    return initial_ss_;
}

uint16_t ne_file::initial_sp() const {
    return initial_sp_;
}

uint16_t ne_file::segment_table_offset() const {
    return segment_table_offset_;
}

uint16_t ne_file::resource_table_offset() const {
    return resource_table_offset_;
}

uint16_t ne_file::resident_name_table_offset() const {
    return resident_name_table_offset_;
}

uint16_t ne_file::module_ref_table_offset() const {
    return module_ref_table_offset_;
}

uint16_t ne_file::import_name_table_offset() const {
    return import_name_table_offset_;
}

uint32_t ne_file::nonresident_name_table_offset() const {
    return nonresident_name_table_offset_;
}

const std::vector<ne_segment>& ne_file::segments() const {
    return segments_;
}

std::optional<ne_segment> ne_file::get_segment(size_t index) const {
    if (index >= segments_.size()) {
        return std::nullopt;
    }
    return segments_[index];
}

std::optional<ne_segment> ne_file::get_code_segment() const {
    // Entry point CS is 1-based segment index (0 means no entry point)
    if (entry_cs_ > 0 && entry_cs_ <= segments_.size()) {
        return segments_[entry_cs_ - 1];  // Convert to 0-based index
    }

    // If no entry point, find first code segment
    // NE segment flags: bit 0 = data (if clear, it's code)
    for (const auto& segment : segments_) {
        if (segment.is_code()) {
            return segment;
        }
    }

    return std::nullopt;
}

uint16_t ne_file::alignment_shift() const {
    return alignment_shift_;
}

bool ne_file::has_resources() const {
    // NE has resources if resource table offset is non-zero and points to valid location
    return resource_table_offset_ > 0 &&
           (ne_offset_ + resource_table_offset_) < data_.size();
}

std::shared_ptr<resource_directory> ne_file::resources() const {
    if (!has_resources()) {
        // Return empty resource directory
        return std::make_shared<ne_resource_directory>(
            std::span<const uint8_t>(),
            std::span<const uint8_t>(),
            0
        );
    }

    // Calculate absolute offset to resource table
    size_t rsrc_table_offset = ne_offset_ + resource_table_offset_;

    // Calculate size of resource table (from resource table to resident name table)
    size_t rsrc_table_size = 0;
    if (resident_name_table_offset_ > resource_table_offset_) {
        rsrc_table_size = resident_name_table_offset_ - resource_table_offset_;
    } else {
        // If we can't determine size, use rest of file
        rsrc_table_size = data_.size() - rsrc_table_offset;
    }

    // Ensure we don't go beyond file boundaries
    if (rsrc_table_offset + rsrc_table_size > data_.size()) {
        rsrc_table_size = data_.size() - rsrc_table_offset;
    }

    // Create spans
    std::span<const uint8_t> rsrc_table_data(
        data_.data() + rsrc_table_offset,
        rsrc_table_size
    );
    std::span<const uint8_t> file_data(data_.data(), data_.size());

    // Use OS/2-aware constructor for OS/2 targets
    return std::make_shared<ne_resource_directory>(
        rsrc_table_data,
        file_data,
        ne_offset_,
        target_os(),
        segments_
    );
}

// =============================================================================
// Entropy Analysis
// =============================================================================

double ne_file::file_entropy() const {
    return entropy_calculator::calculate(data_);
}

double ne_file::segment_entropy(size_t segment_index) const {
    if (segment_index >= segments_.size()) {
        return 0.0;
    }
    const auto& segment = segments_[segment_index];
    if (segment.data.empty()) {
        return 0.0;
    }
    return entropy_calculator::calculate(segment.data);
}

std::vector<std::pair<size_t, double>> ne_file::all_segment_entropies() const {
    std::vector<std::pair<size_t, double>> result;
    result.reserve(segments_.size());
    for (size_t i = 0; i < segments_.size(); ++i) {
        const auto& segment = segments_[i];
        double entropy = segment.data.empty() ? 0.0 : entropy_calculator::calculate(segment.data);
        result.emplace_back(i, entropy);
    }
    return result;
}

bool ne_file::has_high_entropy_segments() const {
    for (const auto& segment : segments_) {
        if (!segment.data.empty()) {
            double entropy = entropy_calculator::calculate(segment.data);
            if (entropy >= entropy_calculator::HIGH_ENTROPY_THRESHOLD) {
                return true;
            }
        }
    }
    return false;
}

bool ne_file::is_likely_packed() const {
    // Check entropy of code segments
    for (const auto& segment : segments_) {
        if (!segment.is_code() || segment.data.empty()) {
            continue;
        }
        double entropy = entropy_calculator::calculate(segment.data);
        // Very high entropy in code segment suggests packing/encryption
        if (entropy >= entropy_calculator::VERY_HIGH_ENTROPY_THRESHOLD) {
            return true;
        }
    }
    return false;
}

} // namespace libexe
