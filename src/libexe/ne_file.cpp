// libexe - Modern executable file analysis library
// Copyright (c) 2024

#include <libexe/ne_file.hpp>
#include "exe_format.hh"  // Generated by DataScript
#include <fstream>
#include <stdexcept>
#include <algorithm>

namespace libexe {

// Helper to read file into memory
static std::vector<uint8_t> read_file_to_memory(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error("Cannot open file: " + path.string());
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error("Cannot read file: " + path.string());
    }

    return buffer;
}

// Factory methods
ne_file ne_file::from_file(const std::filesystem::path& path) {
    auto data = read_file_to_memory(path);
    return from_memory(data);
}

ne_file ne_file::from_memory(std::span<const uint8_t> data) {
    if (data.size() < 64) {  // Minimum for DOS stub + NE header pointer
        throw std::runtime_error("File too small to be a valid NE executable");
    }

    ne_file file;
    file.data_.assign(data.begin(), data.end());

    try {
        file.parse_ne_headers();
        file.parse_segments();
    } catch (const libexe::format::ConstraintViolation& e) {
        throw std::runtime_error(std::string("Invalid NE file: ") + e.what());
    } catch (const std::runtime_error& e) {
        throw std::runtime_error(std::string("Error parsing NE file: ") + e.what());
    }

    return file;
}

void ne_file::parse_ne_headers() {
    const uint8_t* ptr = data_.data();
    const uint8_t* end = ptr + data_.size();

    // Parse DOS header to get e_lfanew (offset to NE header)
    auto dos_header = libexe::format::ImageDosHeader::read(ptr, end);

    if (dos_header.e_magic != libexe::format::DOS_SIGNATURE) {
        throw std::runtime_error("Not a valid DOS/NE file (invalid MZ signature)");
    }

    // Get offset to NE header
    ne_offset_ = dos_header.e_lfanew;
    if (ne_offset_ == 0 || ne_offset_ >= data_.size() - 2) {
        throw std::runtime_error("Not an NE file (e_lfanew invalid)");
    }

    // Parse NE header (DataScript will validate NE signature)
    ptr = data_.data() + ne_offset_;
    auto ne_header = libexe::format::ImageNeHeader::read(ptr, end);

    // Extract header fields
    linker_ver_ = ne_header.ne_ver;
    linker_rev_ = ne_header.ne_rev;
    flags_ = ne_header.ne_flags;
    segment_count_ = ne_header.ne_cseg;
    module_count_ = ne_header.ne_cmod;
    target_os_ = ne_header.ne_exetyp;
    alignment_shift_ = ne_header.ne_align;

    // Extract entry point (CS:IP stored as 32-bit value)
    uint32_t csip = ne_header.ne_csip;
    entry_ip_ = static_cast<uint16_t>(csip & 0xFFFF);
    entry_cs_ = static_cast<uint16_t>((csip >> 16) & 0xFFFF);

    // Extract initial stack (SS:SP stored as 32-bit value)
    uint32_t sssp = ne_header.ne_sssp;
    initial_sp_ = static_cast<uint16_t>(sssp & 0xFFFF);
    initial_ss_ = static_cast<uint16_t>((sssp >> 16) & 0xFFFF);

    // Extract table offsets (relative to NE header start)
    segment_table_offset_ = ne_header.ne_segtab;
    resource_table_offset_ = ne_header.ne_rsrctab;
    resident_name_table_offset_ = ne_header.ne_restab;
    module_ref_table_offset_ = ne_header.ne_modtab;
    import_name_table_offset_ = ne_header.ne_imptab;
    nonresident_name_table_offset_ = ne_header.ne_nrestab;  // Absolute offset
}

void ne_file::parse_segments() {
    if (segment_count_ == 0) {
        return;  // No segments
    }

    const uint8_t* ptr = data_.data() + ne_offset_ + segment_table_offset_;
    const uint8_t* end = data_.data() + data_.size();

    // Parse each segment table entry
    for (uint16_t i = 0; i < segment_count_; i++) {
        if (ptr + 8 > end) break;  // Segment table entry is 8 bytes

        auto seg_entry = libexe::format::NeSegmentTableEntry::read(ptr, end);

        ne_segment segment;
        segment.sector_offset = seg_entry.sector_offset;
        segment.length = seg_entry.length;
        segment.flags = static_cast<ne_segment_flags>(seg_entry.flags);
        segment.min_alloc = seg_entry.min_alloc;

        // Calculate actual file offset using alignment shift
        // offset = sector_offset << alignment_shift
        if (segment.sector_offset > 0) {
            uint32_t file_offset = static_cast<uint32_t>(segment.sector_offset) << alignment_shift_;
            uint32_t actual_length = (segment.length == 0) ? 65536 : segment.length;

            if (file_offset < data_.size()) {
                size_t available = data_.size() - file_offset;
                size_t data_size = std::min(static_cast<size_t>(actual_length), available);

                segment.data = std::span<const uint8_t>(
                    data_.data() + file_offset,
                    data_size
                );
            }
        }

        segments_.push_back(std::move(segment));
    }
}

// Interface implementation
format_type ne_file::get_format() const {
    return format_type::NE_WIN16;
}

std::string_view ne_file::format_name() const {
    // Determine specific OS target
    switch (target_os()) {
        case ne_target_os::OS2:     return "NE (OS/2)";
        case ne_target_os::WINDOWS: return "NE (Windows 16-bit)";
        case ne_target_os::DOS4:    return "NE (European MS-DOS 4.x)";
        case ne_target_os::WIN386:  return "NE (Windows 386)";
        case ne_target_os::BOSS:    return "NE (BOSS - Borland Operating System Services)";
        default:                    return "NE (Unknown target)";
    }
}

std::span<const uint8_t> ne_file::code_section() const {
    auto code_seg = get_code_segment();
    if (code_seg) {
        return code_seg->data;
    }
    return std::span<const uint8_t>();
}

// NE-specific accessors
uint8_t ne_file::linker_version() const {
    return linker_ver_;
}

uint8_t ne_file::linker_revision() const {
    return linker_rev_;
}

ne_file_flags ne_file::flags() const {
    return static_cast<ne_file_flags>(flags_);
}

uint16_t ne_file::segment_count() const {
    return segment_count_;
}

uint16_t ne_file::module_count() const {
    return module_count_;
}

ne_target_os ne_file::target_os() const {
    return static_cast<ne_target_os>(target_os_);
}

uint16_t ne_file::entry_cs() const {
    return entry_cs_;
}

uint16_t ne_file::entry_ip() const {
    return entry_ip_;
}

uint16_t ne_file::initial_ss() const {
    return initial_ss_;
}

uint16_t ne_file::initial_sp() const {
    return initial_sp_;
}

uint16_t ne_file::segment_table_offset() const {
    return segment_table_offset_;
}

uint16_t ne_file::resource_table_offset() const {
    return resource_table_offset_;
}

uint16_t ne_file::resident_name_table_offset() const {
    return resident_name_table_offset_;
}

uint16_t ne_file::module_ref_table_offset() const {
    return module_ref_table_offset_;
}

uint16_t ne_file::import_name_table_offset() const {
    return import_name_table_offset_;
}

uint32_t ne_file::nonresident_name_table_offset() const {
    return nonresident_name_table_offset_;
}

const std::vector<ne_segment>& ne_file::segments() const {
    return segments_;
}

std::optional<ne_segment> ne_file::get_segment(size_t index) const {
    if (index >= segments_.size()) {
        return std::nullopt;
    }
    return segments_[index];
}

std::optional<ne_segment> ne_file::get_code_segment() const {
    // Entry point CS is 1-based segment index (0 means no entry point)
    if (entry_cs_ > 0 && entry_cs_ <= segments_.size()) {
        return segments_[entry_cs_ - 1];  // Convert to 0-based index
    }

    // If no entry point, find first code segment
    // NE segment flags: bit 0 = data, bit 1 = code (actually inverted - if bit 0 clear, it's code)
    for (const auto& segment : segments_) {
        // Code segment: DATA flag is NOT set
        if (!has_flag(segment.flags, ne_segment_flags::DATA)) {
            return segment;
        }
    }

    return std::nullopt;
}

uint16_t ne_file::alignment_shift() const {
    return alignment_shift_;
}

} // namespace libexe
