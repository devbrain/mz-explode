// Windows Dialog Resource Structures (RT_DIALOG)
// Supports NE (16-bit), PE DLGTEMPLATE, and PE DLGTEMPLATEEX formats
package formats.resources.dialogs;

// Global endianness (Windows is little-endian)
little;

// =============================================================================
// Common Constants
// =============================================================================

// DS_SETFONT flag - dialog has font information
const uint32 DS_SETFONT = 0x00000040;

// =============================================================================
// PE (32/64-bit Windows) Dialog Structures
// =============================================================================

// PE resource name-or-ordinal identifier
// Uses inline discriminator choice to detect 0xFFFF prefix
choice resource_name_or_id : uint16 {
    case 0xFFFF:
        uint16 ordinal;
    default:
        little u16string name;
};

// Standard PE dialog template (DLGTEMPLATE)
// NOTE: Standard DLGTEMPLATE does NOT have DWORD alignment between fields!
// Alignment only applies to dialog ITEMS (controls), not the template header.
struct dialog_template {
    uint32 style;
    uint32 extended_style;
    uint16 item_count;
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;

    // Variable-length fields - NOT DWORD aligned in standard template
    resource_name_or_id menu;
    resource_name_or_id window_class;
    little u16string title;

    uint16 point_size optional (style & DS_SETFONT) != 0;
    little u16string typeface optional (style & DS_SETFONT) != 0;
};

// PE dialog item (control) structure - standard DLGITEMTEMPLATE
// NOTE: Each item must START on DWORD boundary (handled by caller),
// but fields within the item are NOT individually aligned.
struct dialog_item {
    uint32 style;
    uint32 extended_style;
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;
    uint16 id;

    // Variable-length fields - NOT individually DWORD aligned
    resource_name_or_id window_class;
    resource_name_or_id title;

    uint16 creation_data_size;
    uint8 creation_data[creation_data_size] optional creation_data_size > 0;
};

// Extended PE dialog template (DLGTEMPLATEEX)
// NOTE: Variable-length fields are NOT individually DWORD-aligned in the header.
// Only the items (controls) need to start on DWORD boundary.
struct dialog_template_ex {
    uint16 version : version == 1;
    uint16 signature : signature == 0xFFFF;
    uint32 help_id;
    uint32 extended_style;
    uint32 style;
    uint16 item_count;
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;

    // Variable-length fields - NOT individually DWORD aligned
    resource_name_or_id menu;
    resource_name_or_id window_class;
    little u16string title;

    // Font info (only if DS_SETFONT is set)
    uint16 point_size optional (style & DS_SETFONT) != 0;
    uint16 weight optional (style & DS_SETFONT) != 0;
    uint8 italic optional (style & DS_SETFONT) != 0;
    uint8 charset optional (style & DS_SETFONT) != 0;
    little u16string typeface optional (style & DS_SETFONT) != 0;
};

// Extended PE dialog item (DLGITEMTEMPLATEEX)
// NOTE: Each item must START on DWORD boundary (handled by caller),
// but fields within the item are NOT individually aligned.
struct dialog_item_ex {
    uint32 help_id;
    uint32 extended_style;
    uint32 style;
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;
    uint32 id;

    // Variable-length fields - NOT individually DWORD aligned
    resource_name_or_id window_class;
    resource_name_or_id title;

    uint16 creation_data_size;
    uint8 creation_data[creation_data_size] optional creation_data_size > 0;
};

// Top-level PE dialog choice (auto-detects standard vs extended)
choice dialog : uint32 {
    case 0xFFFF0001:
        dialog_template_ex extended;
    default:
        dialog_template standard;
};

// =============================================================================
// NE (16-bit Windows) Dialog Structures
// =============================================================================

/**
 * Length-prefixed string (Pascal string) - NE format
 *
 * NE format uses Pascal-style strings: [uint8 length][char data[length]]
 * These are NOT null-terminated!
 *
 * Example binary:
 *   03 46 6F 6F     → length=3, chars="Foo"
 *   00              → length=0, chars="" (empty string)
 *
 * Per ne.fmt specification (line 273): "String table follows (length-prefixed, NOT null-terminated)"
 */
struct ne_pstring {
    uint8 length;               // String length in bytes (0-255)
    uint8 chars[length];        // ASCII/ANSI characters (NOT null-terminated)
};

/**
 * NE resource name-or-ID identifier
 *
 * Format (inline discriminator choice with anonymous structs):
 *   - Peek at first byte
 *   - If 0xFF: consume marker + read uint16 ordinal
 *   - Otherwise: first byte IS the length, read it + chars
 *
 * Per LANGUAGE_GUIDE.md "Inline Discriminator Choices" (lines 399-442):
 * DataScript peeks at the discriminator without consuming it, then each
 * case consumes its own bytes.
 *
 * Using anonymous struct blocks (like union examples in Language Guide).
 */
choice ne_name_or_id : uint8 {
    case 0xFF:
        {
            uint8 marker;              // Consume the 0xFF marker
            uint16 ordinal;            // Read ordinal ID
        } ordinal_value;
    default:
        {
            uint8 length;              // Read length (was peeked, now consumed)
            uint8 chars[length];       // Read chars (inline ne_pstring fields)
        } string_value;
};

/**
 * NE control class identifier
 *
 * Format (range-based discriminator):
 *   - Peek at first byte
 *   - If >= 0x80: it's a predefined class ID (single byte, no more data)
 *   - If < 0x80: it's a null-terminated class name string
 *
 * Predefined class IDs (direct byte value, NOT 0xFF prefix):
 *   0x80 = Button
 *   0x81 = Edit
 *   0x82 = Static
 *   0x83 = List Box
 *   0x84 = Scroll Bar
 *   0x85 = Combo Box
 *
 * Using DataScript's range-based case selector (>= 0x80) to cleanly express
 * the binary format discrimination.
 */
choice ne_control_class : uint8 {
    case >= 0x80:
        { uint8 class_id; } predefined_class;   // Predefined class (Button, Edit, etc.)
    default:
        string custom_class;                    // Null-terminated custom class name
};

/**
 * NE control text identifier
 *
 * Format: Different from ne_name_or_id!
 *   - If first byte is 0xFF: uint16 ordinal follows (resource ID)
 *   - Otherwise: null-terminated string (first byte is first char)
 *
 * NOTE: This is NOT the same as ne_name_or_id which uses length-prefixed strings.
 * NE control text uses null-terminated strings.
 *
 * Since DataScript can't express "if 0xFF then ordinal else null-terminated string"
 * cleanly, we use a choice with 0xFF case and default case for strings.
 */
choice ne_control_text : uint8 {
    case 0xFF:
        {
            uint8 marker;       // Consume the 0xFF marker
            uint16 ordinal;     // Resource ordinal ID
        } ordinal_value;
    default:
        string text;            // Null-terminated string (includes first byte)
};

/**
 * NE Dialog Template (16-bit Windows DLGTEMPLATE)
 *
 * Used by Windows 1.x - 3.x applications.
 * Key differences from PE:
 *   - BYTE item count (not WORD)
 *   - No DWORD alignment
 *   - Mixed string types: null-terminated for template, length-prefixed for controls
 *   - Simpler structure
 *
 * String format rules (discovered through testing):
 *   - menu: ne_name_or_id (0xFF + ordinal OR length-prefixed)
 *   - window_class: null-terminated
 *   - title/caption: null-terminated
 *   - typeface/font: null-terminated
 *   - Control class: ne_control_class (0xFF + byte ID OR length-prefixed)
 *   - Control text: ne_name_or_id (0xFF + ordinal OR length-prefixed)
 */
struct ne_dialog_template {
    uint32 style;
    uint8 item_count;           // BYTE, not WORD like PE
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;

    // Menu name or ID (0xFF prefix for ordinal, else length-prefixed)
    ne_name_or_id menu;

    // Window class (null-terminated, usually empty)
    string window_class;

    // Dialog caption (null-terminated)
    string title;

    // Font info (optional - only if DS_SETFONT is set)
    uint16 point_size optional (style & DS_SETFONT) != 0;
    string typeface optional (style & DS_SETFONT) != 0;  // null-terminated
};

/**
 * NE Dialog Item (control) - 16-bit Windows
 *
 * No DWORD alignment required for NE format.
 */
struct ne_dialog_item {
    int16 x;
    int16 y;
    int16 cx;
    int16 cy;
    uint16 id;
    uint32 style;

    // Control class (predefined or custom byte >= 0x80)
    ne_control_class window_class;

    // Control text or resource ID (0xFF prefix for ordinal, else null-terminated)
    ne_control_text text;

    // Creation data
    uint8 creation_data_size;
    uint8 creation_data[creation_data_size] optional creation_data_size > 0;
};
