# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Branch Context

**Current Branch**: `refactor/datascript-migration`

This branch contains a comprehensive refactoring to transform mz-explode from a specialized MZ decompression tool into a modern executable analysis library. The project is migrating from imperative C++ parsing to declarative DataScript-based format specifications.

## Project Overview

**mz-explode** is evolving into a comprehensive C++20 library for analyzing Windows executable files:
- **Current (Legacy)**: MZ decompression tool supporting PKLITE, LZEXE, EXEPACK, Knowledge Dynamics
- **Target (Modern)**: Full MZ/NE/PE/PE32+ parser with resource extraction and decompression

## Coding Standards (CRITICAL)

### Naming Convention

**DEMAND**: Use `snake_case` everywhere EXCEPT:
- **Macros**: `UPPER_SNAKE_CASE` (e.g., `LIBEXE_VERSION_MAJOR`, `LIBEXE_EXPORT`)
- **Enum values**: `UPPER_SNAKE_CASE` (e.g., `MZ_DOS`, `PKLITE_STANDARD`)

**Examples**:
```cpp
// ✅ CORRECT
class mz_file;                          // snake_case for classes
void decompress_pklite();               // snake_case for functions
int header_size;                        // snake_case for variables
std::vector<uint8_t> raw_data_;         // trailing underscore for private members

#define LIBEXE_VERSION_MAJOR 2          // UPPER_SNAKE_CASE for macros
#define LIBEXE_EXPORT                   // Generated by CMake

enum class compression_type {
    NONE,                               // UPPER_SNAKE_CASE for enum values
    PKLITE_STANDARD,
    LZEXE_091
};

// ❌ INCORRECT - Never use these
class MZFile;                           // PascalCase - NO
class MzFile;                           // PascalCase - NO
void decompressPklite();                // camelCase - NO
int headerSize;                         // camelCase - NO
```

### Directory Structure

```
mz-explode/
├── include/libexe/          # Public API headers (source controlled)
│   ├── export.hpp          # Generated by CMake via generate_export_header
│   ├── executable_file.hpp
│   ├── mz_file.hpp
│   └── decompressors/
│       └── pklite_decompress.hpp
│
├── src/libexe/              # Implementation files
│   ├── mz_file.cpp
│   ├── readers/
│   ├── decompressors/
│   └── core/
│
├── unittests/               # Test suite using doctest
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── test_mz_parser.cpp
│   └── fixtures/
│
├── tools/                   # Command-line utilities
│   ├── mzexplode/main.cpp
│   └── mzdump/main.cpp
│
├── formats/                 # DataScript binary format specifications
│   └── exe_format_complete.ds  # MZ/NE/PE/PE32+ formats (1336 lines)
│
├── generated/               # Auto-generated parsers (NOT committed)
│   └── com_example_exe_parser.h
│
└── docs/                    # Official specifications
    ├── pecoff.docx         # Microsoft PE/COFF spec
    ├── ne.fmt              # NE format spec
    ├── resfmt.txt          # Win32 resource formats
    ├── pklite-114.txt      # PKLite algorithm
    ├── unlzexe.c           # LZEXE reference code
    └── unexepack.c         # EXEPACK reference code
```

## Build System (Modern CMake 3.20+)

### Build Configuration

```bash
# Shared library (default)
cmake -B build
cmake --build build

# Static library
cmake -B build -DBUILD_SHARED_LIBS=OFF
cmake --build build

# Release build
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build

# Without tests
cmake -B build -DBUILD_TESTING=OFF
cmake --build build
```

Build artifacts:
- Library: `build/lib/libexe.so` (or `libexe.a` for static)
- Tools: `build/bin/mzexplode`, `build/bin/mzdump`
- Tests: `build/bin/libexe_unittest`

### Symbol Visibility

**CRITICAL**: Use CMake's `generate_export_header` for portable symbol visibility.

```cmake
include(GenerateExportHeader)

add_library(libexe ...)

# Auto-generates include/libexe/export.hpp with LIBEXE_EXPORT macro
generate_export_header(libexe
    BASE_NAME libexe
    EXPORT_FILE_NAME ${CMAKE_CURRENT_BINARY_DIR}/include/libexe/export.hpp
)

# Hide all symbols by default (like Windows)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN YES)
```

**Usage in headers**:
```cpp
#include <libexe/export.hpp>

namespace libexe {

class LIBEXE_EXPORT mz_file {  // Explicitly exported
public:
    // ...
};

} // namespace libexe
```

## Architecture Overview

### DataScript-Based Parsing

**Key Innovation**: Binary format specifications are declarative, not imperative.

```
formats/exe_format_complete.ds (DataScript)
           ↓ (code generation)
generated/com_example_exe_parser.h (C++ parser)
           ↓ (wrapped by)
include/libexe/mz_file.hpp (high-level API)
```

**DataScript Advantages**:
- Format specification IS the documentation
- Automatic validation (magic numbers, constraints)
- Handles endianness, alignment, variable-length arrays
- Zero runtime dependencies (generated code is self-contained)

**Code Generation**:
```bash
# Single-header mode (production)
ds formats/exe_format_complete.ds -t cpp -o generated/

# Library mode (with introspection for debugging)
ds formats/exe_format_complete.ds -t cpp --library -o generated/
```

### Module Separation

**Legacy** (src/explode/): Monolithic decoders mixing parsing + decompression
**Modern** (include/libexe/, src/libexe/): Clean separation

```cpp
// PARSING: Auto-generated from DataScript
#include "com_example_exe_parser.h"
auto parsed = Executable::read(data.data(), data.data() + data.size());

// HIGH-LEVEL API: Type-safe wrappers (snake_case)
#include <libexe/mz_file.hpp>
auto exe = libexe::mz_file::from_file("program.exe");

// DECOMPRESSION: Pure algorithms (testable in isolation)
#include <libexe/decompressors/pklite_decompress.hpp>
auto decompressed = libexe::pklite_decompressor::decompress(
    exe.code_section(),
    header
);
```

## Testing Framework

**Testing**: doctest (same as datascript uses)

```cmake
# unittests/CMakeLists.txt
find_package(doctest QUIET)
if(NOT doctest_FOUND)
    FetchContent_Declare(doctest
        GIT_REPOSITORY https://github.com/doctest/doctest.git
        GIT_TAG v2.4.12
    )
    FetchContent_MakeAvailable(doctest)
endif()

add_executable(libexe_unittest
    main.cpp
    test_mz_parser.cpp
    test_pklite_decompress.cpp
)
target_link_libraries(libexe_unittest PRIVATE libexe doctest::doctest)
```

**Running tests**:
```bash
./build/bin/libexe_unittest
```

## Modern C++20 API Design

### Public API Example (snake_case)

```cpp
// include/libexe/mz_file.hpp
#ifndef LIBEXE_MZ_FILE_HPP
#define LIBEXE_MZ_FILE_HPP

#include <libexe/export.hpp>
#include <libexe/executable_file.hpp>
#include <filesystem>
#include <span>
#include <cstdint>

namespace libexe {

enum class compression_type {
    NONE,
    PKLITE_STANDARD,
    PKLITE_EXTRA,
    LZEXE_090,
    LZEXE_091,
    EXEPACK,
    KNOWLEDGE_DYNAMICS
};

class LIBEXE_EXPORT mz_file : public executable_file {
public:
    // Factory methods
    static mz_file from_file(const std::filesystem::path& path);
    static mz_file from_memory(std::span<const uint8_t> data);

    // Format detection
    compression_type get_compression() const;
    bool is_compressed() const;

    // DOS header accessors
    uint16_t initial_cs() const;
    uint16_t initial_ip() const;
    uint16_t initial_ss() const;
    uint16_t initial_sp() const;

    // Data access
    std::span<const uint8_t> code_section() const override;

private:
    std::vector<uint8_t> data_;
    compression_type compression_;
};

} // namespace libexe

#endif // LIBEXE_MZ_FILE_HPP
```

## Development Workflow

### Adding a New Format Parser

1. **Create DataScript specification**: `formats/new_format.ds`
2. **Define structures** with validation constraints
3. **Generate parser**: `ds formats/new_format.ds -t cpp -o generated/`
4. **Create wrapper class**: `include/libexe/new_format_file.hpp` (snake_case)
5. **Implement wrapper**: `src/libexe/new_format_file.cpp`
6. **Write tests**: `unittests/test_new_format_parser.cpp`

### Adding a Decompression Algorithm

1. **Create header**: `include/libexe/decompressors/algorithm_decompress.hpp`
2. **Implement as pure function**: Takes `std::span`, returns `std::vector<uint8_t>`
3. **No I/O dependencies**: Algorithm is testable in isolation
4. **Write comprehensive tests**: Known input/output pairs

## Migration Status

**Current Focus**: Phase 1 - Foundation & Proof of Concept

- [x] Establish coding standards (snake_case)
- [x] Obtain complete format specifications (exe_format_complete.ds)
- [ ] Set up directory structure (include/, src/, unittests/)
- [ ] Configure CMake with generate_export_header
- [ ] Integrate doctest testing framework
- [ ] Generate first parser from exe_format_complete.ds
- [ ] Create mz_file wrapper with snake_case API
- [ ] Write comparison tests against legacy implementation

**See**: `MIGRATION_STRATEGY.md` for the complete 7-phase refactoring plan.

## Dependencies

**Build-time**:
- CMake 3.20+
- C++20 compiler (GCC 10+, Clang 12+, MSVC 2019+)
- datascript (fetched via CMake FetchContent)

**Runtime**:
- failsafe (header-only logging/exceptions): https://github.com/devbrain/failsafe
- Zero dependencies for generated parsers

**Testing**:
- doctest (fetched via CMake FetchContent)

## Key Files for Understanding

**Format Specifications**:
- `formats/exe_format_complete.ds` - Complete MZ/NE/PE/PE32+ definitions
- `docs/pecoff.docx` - Official Microsoft PE/COFF specification
- `docs/ne.fmt` - NE (16-bit Windows) format specification

**Legacy Implementation** (for reference):
- `src/explode/exe_file.cc` - Old MZ header parsing (manual, imperative)
- `src/explode/unpklite.cc` - Old PKLITE decoder (parsing + decompression mixed)

**Migration Documents**:
- `MIGRATION_STRATEGY.md` - Complete 7-phase refactoring plan
- `README.md` - Project overview and current status

## Important Reminders

1. **Always use snake_case** (except macros and enum values)
2. **Use generate_export_header** for symbol visibility
3. **Separate parsing from algorithms** (DataScript vs. decompression)
4. **Test with doctest**, not custom frameworks
5. **Modern C++20**: Use `std::span`, `std::filesystem::path`, ranges
6. **Zero manual memory management**: RAII, smart pointers, STL containers
7. **Validate against official specs** in `docs/` directory
